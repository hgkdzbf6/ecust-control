   1              		.file	"uart.c"
   3              		.text
   4              	.Ltext0:
 137              		.global	data_requested
 138              		.bss
 141              	data_requested:
 142 0000 00       		.space	1
 143              		.global	chksum_to_check
 146              	chksum_to_check:
 147 0001 00       		.space	1
 148              		.global	chksum_trigger
 149              		.data
 152              	chksum_trigger:
 153 0000 01       		.byte	1
 154              		.global	transmission_running
 155              		.bss
 158              	transmission_running:
 159 0002 00       		.space	1
 160              		.global	transmission1_running
 163              	transmission1_running:
 164 0003 00       		.space	1
 165              		.global	trigger_transmission
 168              	trigger_transmission:
 169 0004 00       		.space	1
 170              		.global	baudrate1_change
 173              	baudrate1_change:
 174 0005 00       		.space	1
 175              		.global	UART_syncstate
 178              	UART_syncstate:
 179 0006 00       		.space	1
 180              		.global	UART1_syncstate
 183              	UART1_syncstate:
 184 0007 00       		.space	1
 185              		.global	UART_rxcount
 186              		.align	2
 189              	UART_rxcount:
 190 0008 00000000 		.space	4
 191              		.global	UART1_rxcount
 192              		.align	2
 195              	UART1_rxcount:
 196 000c 00000000 		.space	4
 197              		.global	UART_CalibDoneFlag
 200              	UART_CalibDoneFlag:
 201 0010 00       		.space	1
 202              	rb_busy:
 203 0011 00       		.space	1
 204              		.global	startstring
 205              		.data
 208              	startstring:
 209 0001 3E       		.byte	62
 210 0002 2A       		.byte	42
 211 0003 3E       		.byte	62
 212              		.global	stopstring
 215              	stopstring:
 216 0004 3C       		.byte	60
 217 0005 23       		.byte	35
 218 0006 3C       		.byte	60
 219              		.text
 220              		.align	2
 222              		.global	uart1ISR
 224              	uart1ISR:
   1:uart.c        **** /*
   2:uart.c        **** 
   3:uart.c        **** Copyright (c) 2011, Ascending Technologies GmbH
   4:uart.c        **** All rights reserved.
   5:uart.c        **** 
   6:uart.c        **** Redistribution and use in source and binary forms, with or without
   7:uart.c        **** modification, are permitted provided that the following conditions are met:
   8:uart.c        **** 
   9:uart.c        ****  * Redistributions of source code must retain the above copyright notice,
  10:uart.c        ****    this list of conditions and the following disclaimer.
  11:uart.c        ****  * Redistributions in binary form must reproduce the above copyright
  12:uart.c        ****    notice, this list of conditions and the following disclaimer in the
  13:uart.c        ****    documentation and/or other materials provided with the distribution.
  14:uart.c        **** 
  15:uart.c        **** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
  16:uart.c        **** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17:uart.c        **** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  18:uart.c        **** DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
  19:uart.c        **** DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  20:uart.c        **** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  21:uart.c        **** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  22:uart.c        **** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  23:uart.c        **** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  24:uart.c        **** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  25:uart.c        **** DAMAGE.
  26:uart.c        **** 
  27:uart.c        ****  */
  28:uart.c        **** 
  29:uart.c        **** #include "LPC214x.h"
  30:uart.c        **** #include "system.h"
  31:uart.c        **** #include "main.h"
  32:uart.c        **** #include "buzzer.h"
  33:uart.c        **** #include "uart.h"
  34:uart.c        **** #include "irq.h"
  35:uart.c        **** #include "hardware.h"
  36:uart.c        **** #include "gpsmath.h"
  37:uart.c        **** #include "ssp.h"
  38:uart.c        **** #include "sdk.h"
  39:uart.c        **** #include "ublox.h"
  40:uart.c        **** #include "pid.h"
  41:uart.c        **** #include "position_controller.h"
  42:uart.c        **** 
  43:uart.c        **** unsigned char packets;
  44:uart.c        **** unsigned char DataOutputsPerSecond;
  45:uart.c        **** unsigned int uart_cnt;
  46:uart.c        **** 
  47:uart.c        **** unsigned char data_requested=0;
  48:uart.c        **** extern int ZeroDepth;
  49:uart.c        **** 
  50:uart.c        **** unsigned short current_chksum;
  51:uart.c        **** unsigned char chksum_to_check=0;
  52:uart.c        **** unsigned char chksum_trigger=1;
  53:uart.c        **** 
  54:uart.c        **** unsigned char transmission_running=0;
  55:uart.c        **** unsigned char transmission1_running=0;
  56:uart.c        **** unsigned char trigger_transmission=0;
  57:uart.c        **** 
  58:uart.c        **** volatile unsigned char baudrate1_change=0;
  59:uart.c        **** 
  60:uart.c        **** unsigned char send_buffer[16];
  61:uart.c        **** unsigned char *tx_buff;
  62:uart.c        **** unsigned char UART_syncstate=0;
  63:uart.c        **** unsigned char UART1_syncstate=0;
  64:uart.c        **** unsigned int UART_rxcount=0;
  65:uart.c        **** unsigned char *UART_rxptr;
  66:uart.c        **** unsigned int UART1_rxcount=0;
  67:uart.c        **** unsigned char *UART1_rxptr;
  68:uart.c        **** 
  69:uart.c        **** unsigned char UART_CalibDoneFlag = 0;
  70:uart.c        **** 
  71:uart.c        **** static volatile unsigned char rb_busy=0;
  72:uart.c        **** 
  73:uart.c        **** unsigned char startstring[]={'>','*','>'};
  74:uart.c        **** unsigned char stopstring[]={'<','#','<'};
  75:uart.c        **** 
  76:uart.c        **** 
  77:uart.c        **** unsigned char my_buffer[256];
  78:uart.c        **** extern unsigned char allDataBuffer[256];
  79:uart.c        **** extern MyViconData receivedViconData;
  80:uart.c        **** extern ParamDebug sendParamDebug;
  81:uart.c        **** extern ParamDebug receiveParamDebug;
  82:uart.c        **** extern DebugData sendDebugData;
  83:uart.c        **** extern DebugData receiveDebugData;
  84:uart.c        **** extern int vicon_count;
  85:uart.c        **** extern int receive_valid_data_flag;
  86:uart.c        **** extern struct this_s my_this ;
  87:uart.c        **** extern state_t my_state;
  88:uart.c        **** extern int output_thrust;
  89:uart.c        **** extern CmdData receiveCmdData;
  90:uart.c        **** extern int pack_id;
  91:uart.c        **** extern int vicon_tp;
  92:uart.c        **** 
  93:uart.c        **** void uart1ISR(void) __irq
  94:uart.c        **** {
 226              	.LM0:
 227              		@ Function supports interworking.
 228              		@ args = 0, pretend = 0, frame = 12
 229              		@ frame_needed = 1, uses_anonymous_args = 0
 230 0000 0DC0A0E1 		mov	ip, sp
 231 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 232 0008 04B04CE2 		sub	fp, ip, #4
 233 000c 0CD04DE2 		sub	sp, sp, #12
  95:uart.c        ****   unsigned char t;
  96:uart.c        ****   IENABLE;
  97:uart.c        ****   unsigned iir = U1IIR;
 235              	.LM1:
 236 0010 8E32A0E3 		mov	r3, #-536870904
 237 0014 013883E2 		add	r3, r3, #65536
 238 0018 003093E5 		ldr	r3, [r3, #0]
 239 001c 10300BE5 		str	r3, [fp, #-16]
  98:uart.c        ****   // Handle UART interrupt
  99:uart.c        ****   switch ((iir >> 1) & 0x7)
 241              	.LM2:
 242 0020 10301BE5 		ldr	r3, [fp, #-16]
 243 0024 A330A0E1 		mov	r3, r3, lsr #1
 244 0028 073003E2 		and	r3, r3, #7
 245 002c 18300BE5 		str	r3, [fp, #-24]
 246 0030 18301BE5 		ldr	r3, [fp, #-24]
 247 0034 010053E3 		cmp	r3, #1
 248 0038 0300000A 		beq	.L3
 249 003c 18301BE5 		ldr	r3, [fp, #-24]
 250 0040 020053E3 		cmp	r3, #2
 251 0044 1300000A 		beq	.L4
 252 0048 180000EA 		b	.L2
 253              	.L3:
 100:uart.c        ****     {
 101:uart.c        ****       case 1:
 102:uart.c        **** 		  // THRE interrupt
 103:uart.c        **** 		 if (ringbuffer1(RBREAD, &t, 1))
 255              	.LM3:
 256 004c 11304BE2 		sub	r3, fp, #17
 257 0050 0000A0E3 		mov	r0, #0
 258 0054 0310A0E1 		mov	r1, r3
 259 0058 0120A0E3 		mov	r2, #1
 260 005c FEFFFFEB 		bl	ringbuffer1
 261 0060 0030A0E1 		mov	r3, r0
 262 0064 000053E3 		cmp	r3, #0
 263 0068 0600000A 		beq	.L5
 104:uart.c        **** 		 {
 105:uart.c        **** 		   transmission1_running=1;
 265              	.LM4:
 266 006c 58209FE5 		ldr	r2, .L9
 267 0070 0130A0E3 		mov	r3, #1
 268 0074 0030C2E5 		strb	r3, [r2, #0]
 106:uart.c        **** 		   UART1WriteChar(t);
 270              	.LM5:
 271 0078 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 272 007c 0300A0E1 		mov	r0, r3
 273 0080 FEFFFFEB 		bl	UART1WriteChar
 274 0084 090000EA 		b	.L2
 275              	.L5:
 107:uart.c        **** 		 }
 108:uart.c        **** 		 else
 109:uart.c        **** 		 {
 110:uart.c        **** 		   transmission1_running=0;
 277              	.LM6:
 278 0088 3C309FE5 		ldr	r3, .L9
 279 008c 0020A0E3 		mov	r2, #0
 280 0090 0020C3E5 		strb	r2, [r3, #0]
 111:uart.c        **** 		 }
 112:uart.c        ****         break;
 282              	.LM7:
 283 0094 050000EA 		b	.L2
 284              	.L4:
 113:uart.c        ****       case 2:
 114:uart.c        ****     	// RX interrupt
 115:uart.c        **** 	    uBloxReceiveHandler(U1RBR);
 286              	.LM8:
 287 0098 0E32A0E3 		mov	r3, #-536870912
 288 009c 013883E2 		add	r3, r3, #65536
 289 00a0 003093E5 		ldr	r3, [r3, #0]
 290 00a4 FF3003E2 		and	r3, r3, #255
 291 00a8 0300A0E1 		mov	r0, r3
 292 00ac FEFFFFEB 		bl	uBloxReceiveHandler
 293              	.L2:
 116:uart.c        **** 	    break;
 117:uart.c        ****       case 3:
 118:uart.c        ****         // RLS interrupt
 119:uart.c        ****         break;
 120:uart.c        ****       case 6:
 121:uart.c        ****         // CTI interrupt
 122:uart.c        ****         break;
 123:uart.c        ****    }
 124:uart.c        ****   IDISABLE;
 125:uart.c        ****   VICVectAddr = 0;		/* Acknowledge Interrupt */
 295              	.LM9:
 296 00b0 0030A0E3 		mov	r3, #0
 297 00b4 FD3E43E2 		sub	r3, r3, #4048
 298 00b8 0020A0E3 		mov	r2, #0
 299 00bc 002083E5 		str	r2, [r3, #0]
 126:uart.c        **** }
 301              	.LM10:
 302 00c0 0CD04BE2 		sub	sp, fp, #12
 303 00c4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 304 00c8 1EFF2FE1 		bx	lr
 305              	.L10:
 306              		.align	2
 307              	.L9:
 308 00cc 00000000 		.word	transmission1_running
 314              	.Lscope0:
 315              		.global	__nesf2
 316              		.align	2
 318              		.global	uart0ISR
 320              	uart0ISR:
 127:uart.c        **** 
 128:uart.c        **** 
 129:uart.c        **** 
 130:uart.c        **** void uart0ISR(void) __irq
 131:uart.c        **** {
 322              	.LM11:
 323              		@ Function supports interworking.
 324              		@ args = 0, pretend = 0, frame = 12
 325              		@ frame_needed = 1, uses_anonymous_args = 0
 326 00d0 0DC0A0E1 		mov	ip, sp
 327 00d4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 328 00d8 04B04CE2 		sub	fp, ip, #4
 329 00dc 10D04DE2 		sub	sp, sp, #16
 132:uart.c        ****   unsigned char t;
 133:uart.c        ****   unsigned char receive_result;
 134:uart.c        ****   unsigned char UART_rxdata;
 135:uart.c        **** 
 136:uart.c        ****   // Read IIR to clear interrupt and find out the cause
 137:uart.c        ****   IENABLE;
 138:uart.c        ****   unsigned iir = U0IIR;
 331              	.LM12:
 332 00e0 0339A0E3 		mov	r3, #49152
 333 00e4 8E3283E2 		add	r3, r3, #-536870904
 334 00e8 003093E5 		ldr	r3, [r3, #0]
 335 00ec 10300BE5 		str	r3, [fp, #-16]
 139:uart.c        ****   // Handle UART interrupt
 140:uart.c        ****   switch ((iir >> 1) & 0x7)
 337              	.LM13:
 338 00f0 10301BE5 		ldr	r3, [fp, #-16]
 339 00f4 A330A0E1 		mov	r3, r3, lsr #1
 340 00f8 073003E2 		and	r3, r3, #7
 341 00fc 18300BE5 		str	r3, [fp, #-24]
 342 0100 18301BE5 		ldr	r3, [fp, #-24]
 343 0104 010053E3 		cmp	r3, #1
 344 0108 0300000A 		beq	.L13
 345 010c 18301BE5 		ldr	r3, [fp, #-24]
 346 0110 020053E3 		cmp	r3, #2
 347 0114 2000000A 		beq	.L14
 348 0118 D30000EA 		b	.L12
 349              	.L13:
 141:uart.c        ****     {
 142:uart.c        ****       case 1:
 143:uart.c        ****         // THRE interrupt
 144:uart.c        **** 		if(!(IOPIN0&(1<<CTS_RADIO)))
 351              	.LM14:
 352 011c 0E32A0E3 		mov	r3, #-536870912
 353 0120 0A3983E2 		add	r3, r3, #163840
 354 0124 003093E5 		ldr	r3, [r3, #0]
 355 0128 013503E2 		and	r3, r3, #4194304
 356 012c 000053E3 		cmp	r3, #0
 357 0130 1500001A 		bne	.L15
 145:uart.c        **** 		{
 146:uart.c        **** 			trigger_transmission=0;
 359              	.LM15:
 360 0134 4C239FE5 		ldr	r2, .L35
 361 0138 0030A0E3 		mov	r3, #0
 362 013c 0030C2E5 		strb	r3, [r2, #0]
 147:uart.c        **** 			 if (ringbuffer(RBREAD, &t, 1))
 364              	.LM16:
 365 0140 13304BE2 		sub	r3, fp, #19
 366 0144 0000A0E3 		mov	r0, #0
 367 0148 0310A0E1 		mov	r1, r3
 368 014c 0120A0E3 		mov	r2, #1
 369 0150 FEFFFFEB 		bl	ringbuffer
 370 0154 0030A0E1 		mov	r3, r0
 371 0158 000053E3 		cmp	r3, #0
 372 015c 0600000A 		beq	.L17
 148:uart.c        **** 		     {
 149:uart.c        **** 		       transmission_running=1;
 374              	.LM17:
 375 0160 24239FE5 		ldr	r2, .L35+4
 376 0164 0130A0E3 		mov	r3, #1
 377 0168 0030C2E5 		strb	r3, [r2, #0]
 150:uart.c        **** 		       UARTWriteChar(t);
 379              	.LM18:
 380 016c 13305BE5 		ldrb	r3, [fp, #-19]	@ zero_extendqisi2
 381 0170 0300A0E1 		mov	r0, r3
 382 0174 FEFFFFEB 		bl	UARTWriteChar
 383 0178 BB0000EA 		b	.L12
 384              	.L17:
 151:uart.c        **** 		     }
 152:uart.c        **** 		     else
 153:uart.c        **** 		     {
 154:uart.c        **** 		       transmission_running=0;
 386              	.LM19:
 387 017c 08339FE5 		ldr	r3, .L35+4
 388 0180 0020A0E3 		mov	r2, #0
 389 0184 0020C3E5 		strb	r2, [r3, #0]
 390 0188 B70000EA 		b	.L12
 391              	.L15:
 155:uart.c        **** 		     }
 156:uart.c        **** 		}
 157:uart.c        **** 		else
 158:uart.c        **** 		{
 159:uart.c        **** 			trigger_transmission=1;
 393              	.LM20:
 394 018c F4329FE5 		ldr	r3, .L35
 395 0190 0120A0E3 		mov	r2, #1
 396 0194 0020C3E5 		strb	r2, [r3, #0]
 160:uart.c        **** 		}
 161:uart.c        **** 		break;
 398              	.LM21:
 399 0198 B30000EA 		b	.L12
 400              	.L14:
 162:uart.c        **** 
 163:uart.c        ****       case 2:
 164:uart.c        ****         // RDA interrupt - put your HL_serial_0 receive state machine here!
 165:uart.c        ****         UART_rxdata = U0RBR;
 402              	.LM22:
 403 019c 0E32A0E3 		mov	r3, #-536870912
 404 01a0 033983E2 		add	r3, r3, #49152
 405 01a4 003093E5 		ldr	r3, [r3, #0]
 406 01a8 11304BE5 		strb	r3, [fp, #-17]
 166:uart.c        **** #ifdef DEBUG_DATA_MODE
 167:uart.c        ****         receive_result=my_receive(UART_rxdata,my_buffer,
 408              	.LM23:
 409 01ac 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 410 01b0 0130A0E3 		mov	r3, #1
 411 01b4 00308DE5 		str	r3, [sp, #0]
 412 01b8 0200A0E1 		mov	r0, r2
 413 01bc CC129FE5 		ldr	r1, .L35+8
 414 01c0 CC229FE5 		ldr	r2, .L35+12
 415 01c4 CC329FE5 		ldr	r3, .L35+16
 416 01c8 FEFFFFEB 		bl	my_receive
 417 01cc 0030A0E1 		mov	r3, r0
 418 01d0 12304BE5 		strb	r3, [fp, #-18]
 168:uart.c        **** 				allDataBuffer,&pack_id,1);
 169:uart.c        **** 		if(receive_result==RECEIVE_STATE_SUCCESS){
 420              	.LM24:
 421 01d4 12305BE5 		ldrb	r3, [fp, #-18]	@ zero_extendqisi2
 422 01d8 020053E3 		cmp	r3, #2
 423 01dc A200001A 		bne	.L12
 170:uart.c        **** 			switch(pack_id){
 425              	.LM25:
 426 01e0 B0329FE5 		ldr	r3, .L35+16
 427 01e4 003093E5 		ldr	r3, [r3, #0]
 428 01e8 013043E2 		sub	r3, r3, #1
 429 01ec 060053E3 		cmp	r3, #6
 430 01f0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 431 01f4 9C0000EA 		b	.L12
 432              		.align	2
 433              	.L29:
 434 01f8 6C040000 		.word	.L12
 435 01fc 14020000 		.word	.L23
 436 0200 6C040000 		.word	.L12
 437 0204 6C040000 		.word	.L12
 438 0208 80020000 		.word	.L26
 439 020c 3C030000 		.word	.L27
 440 0210 38040000 		.word	.L28
 441              	.L23:
 171:uart.c        **** 			case PACKAGE_DEFINE_STATUS:
 172:uart.c        **** 				break;
 173:uart.c        **** 			case PACKAGE_DEFINE_VICON:
 174:uart.c        **** 				memcpy(&receivedViconData,
 443              	.LM26:
 444 0214 7C329FE5 		ldr	r3, .L35+16
 445 0218 003093E5 		ldr	r3, [r3, #0]
 446 021c 0300A0E1 		mov	r0, r3
 447 0220 FEFFFFEB 		bl	getPackageLength
 448 0224 0030A0E1 		mov	r3, r0
 449 0228 0310A0E1 		mov	r1, r3
 450 022c 68329FE5 		ldr	r3, .L35+20
 451 0230 5C229FE5 		ldr	r2, .L35+12
 452 0234 01C0A0E1 		mov	ip, r1
 453 0238 0300A0E1 		mov	r0, r3
 454 023c 0210A0E1 		mov	r1, r2
 455 0240 0C20A0E1 		mov	r2, ip
 456 0244 FEFFFFEB 		bl	memcpy
 175:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 176:uart.c        **** 				my_state.position.z=receivedViconData.z;
 458              	.LM27:
 459 0248 4C329FE5 		ldr	r3, .L35+20
 460 024c 0C2093E5 		ldr	r2, [r3, #12]	@ float
 461 0250 48329FE5 		ldr	r3, .L35+24
 462 0254 082083E5 		str	r2, [r3, #8]	@ float
 177:uart.c        **** 				my_state.velocity.z=receivedViconData.vz;
 464              	.LM28:
 465 0258 3C329FE5 		ldr	r3, .L35+20
 466 025c 242093E5 		ldr	r2, [r3, #36]	@ float
 467 0260 38329FE5 		ldr	r3, .L35+24
 468 0264 142083E5 		str	r2, [r3, #20]	@ float
 178:uart.c        **** 				vicon_count++;
 470              	.LM29:
 471 0268 34329FE5 		ldr	r3, .L35+28
 472 026c 003093E5 		ldr	r3, [r3, #0]
 473 0270 012083E2 		add	r2, r3, #1
 474 0274 28329FE5 		ldr	r3, .L35+28
 475 0278 002083E5 		str	r2, [r3, #0]
 179:uart.c        **** 				break;
 477              	.LM30:
 478 027c 7A0000EA 		b	.L12
 479              	.L26:
 180:uart.c        **** 			case PACKAGE_DEFINE_SENSOR:
 181:uart.c        **** 				break;
 182:uart.c        **** 			case PACKAGE_DEFINE_FUSION:
 183:uart.c        **** 				break;
 184:uart.c        **** 			case PACKAGE_DEFINE_DEBUG:
 185:uart.c        **** 				memcpy(&receiveDebugData,
 481              	.LM31:
 482 0280 10329FE5 		ldr	r3, .L35+16
 483 0284 003093E5 		ldr	r3, [r3, #0]
 484 0288 0300A0E1 		mov	r0, r3
 485 028c FEFFFFEB 		bl	getPackageLength
 486 0290 0030A0E1 		mov	r3, r0
 487 0294 0310A0E1 		mov	r1, r3
 488 0298 08329FE5 		ldr	r3, .L35+32
 489 029c F0219FE5 		ldr	r2, .L35+12
 490 02a0 01C0A0E1 		mov	ip, r1
 491 02a4 0300A0E1 		mov	r0, r3
 492 02a8 0210A0E1 		mov	r1, r2
 493 02ac 0C20A0E1 		mov	r2, ip
 494 02b0 FEFFFFEB 		bl	memcpy
 186:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 187:uart.c        **** 				my_state.position.x=receiveDebugData.x;
 496              	.LM32:
 497 02b4 EC319FE5 		ldr	r3, .L35+32
 498 02b8 042093E5 		ldr	r2, [r3, #4]	@ float
 499 02bc DC319FE5 		ldr	r3, .L35+24
 500 02c0 002083E5 		str	r2, [r3, #0]	@ float
 188:uart.c        **** 				my_state.position.y=receiveDebugData.y;
 502              	.LM33:
 503 02c4 DC319FE5 		ldr	r3, .L35+32
 504 02c8 082093E5 		ldr	r2, [r3, #8]	@ float
 505 02cc CC319FE5 		ldr	r3, .L35+24
 506 02d0 042083E5 		str	r2, [r3, #4]	@ float
 189:uart.c        **** 				my_state.position.z=receiveDebugData.z;
 508              	.LM34:
 509 02d4 CC319FE5 		ldr	r3, .L35+32
 510 02d8 0C2093E5 		ldr	r2, [r3, #12]	@ float
 511 02dc BC319FE5 		ldr	r3, .L35+24
 512 02e0 082083E5 		str	r2, [r3, #8]	@ float
 190:uart.c        **** 				//my_state.velocity.x=receiveDebugData.vx;
 191:uart.c        **** 				//my_state.velocity.y=receiveDebugData.vy;
 192:uart.c        **** 				//my_state.velocity.z=receiveDebugData.vz;
 193:uart.c        **** 				my_state.attitude.pitch=receiveDebugData.pitch;
 514              	.LM35:
 515 02e4 BC319FE5 		ldr	r3, .L35+32
 516 02e8 1C2093E5 		ldr	r2, [r3, #28]	@ float
 517 02ec AC319FE5 		ldr	r3, .L35+24
 518 02f0 202083E5 		str	r2, [r3, #32]	@ float
 194:uart.c        **** 				my_state.attitude.roll=receiveDebugData.roll;
 520              	.LM36:
 521 02f4 AC319FE5 		ldr	r3, .L35+32
 522 02f8 202093E5 		ldr	r2, [r3, #32]	@ float
 523 02fc 9C319FE5 		ldr	r3, .L35+24
 524 0300 1C2083E5 		str	r2, [r3, #28]	@ float
 195:uart.c        **** 				my_state.attitude.yaw=receiveDebugData.yaw;
 526              	.LM37:
 527 0304 9C319FE5 		ldr	r3, .L35+32
 528 0308 242093E5 		ldr	r2, [r3, #36]	@ float
 529 030c 8C319FE5 		ldr	r3, .L35+24
 530 0310 242083E5 		str	r2, [r3, #36]	@ float
 196:uart.c        **** 				vicon_tp=receiveDebugData.timestamp;
 532              	.LM38:
 533 0314 8C319FE5 		ldr	r3, .L35+32
 534 0318 002093E5 		ldr	r2, [r3, #0]
 535 031c 88319FE5 		ldr	r3, .L35+36
 536 0320 002083E5 		str	r2, [r3, #0]
 197:uart.c        **** 				vicon_count++;
 538              	.LM39:
 539 0324 78319FE5 		ldr	r3, .L35+28
 540 0328 003093E5 		ldr	r3, [r3, #0]
 541 032c 012083E2 		add	r2, r3, #1
 542 0330 6C319FE5 		ldr	r3, .L35+28
 543 0334 002083E5 		str	r2, [r3, #0]
 198:uart.c        **** 				break;
 545              	.LM40:
 546 0338 4B0000EA 		b	.L12
 547              	.L27:
 199:uart.c        **** 			case PACKAGE_DEFINE_PARAM:
 200:uart.c        **** 				memcpy(&receiveParamDebug,
 549              	.LM41:
 550 033c 54319FE5 		ldr	r3, .L35+16
 551 0340 003093E5 		ldr	r3, [r3, #0]
 552 0344 0300A0E1 		mov	r0, r3
 553 0348 FEFFFFEB 		bl	getPackageLength
 554 034c 0030A0E1 		mov	r3, r0
 555 0350 0310A0E1 		mov	r1, r3
 556 0354 54319FE5 		ldr	r3, .L35+40
 557 0358 34219FE5 		ldr	r2, .L35+12
 558 035c 01C0A0E1 		mov	ip, r1
 559 0360 0300A0E1 		mov	r0, r3
 560 0364 0210A0E1 		mov	r1, r2
 561 0368 0C20A0E1 		mov	r2, ip
 562 036c FEFFFFEB 		bl	memcpy
 201:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 202:uart.c        **** 	        	if(receive_valid_data_flag==1||receiveParamDebug.kp_p!=0){
 564              	.LM42:
 565 0370 3C319FE5 		ldr	r3, .L35+44
 566 0374 003093E5 		ldr	r3, [r3, #0]
 567 0378 010053E3 		cmp	r3, #1
 568 037c 0800000A 		beq	.L30
 569 0380 28319FE5 		ldr	r3, .L35+40
 570 0384 0C3093E5 		ldr	r3, [r3, #12]	@ float
 571 0388 0300A0E1 		mov	r0, r3
 572 038c 24119FE5 		ldr	r1, .L35+48	@ float
 573 0390 FEFFFFEB 		bl	__nesf2
 574 0394 0030A0E1 		mov	r3, r0
 575 0398 000053E3 		cmp	r3, #0
 576 039c 0000001A 		bne	.L30
 577 03a0 160000EA 		b	.L32
 578              	.L30:
 203:uart.c        **** 	        		receive_valid_data_flag=1;
 580              	.LM43:
 581 03a4 08219FE5 		ldr	r2, .L35+44
 582 03a8 0130A0E3 		mov	r3, #1
 583 03ac 003082E5 		str	r3, [r2, #0]
 204:uart.c        **** 	        		my_this.pidZ.pid.kp=receiveParamDebug.kp_p;
 585              	.LM44:
 586 03b0 F8309FE5 		ldr	r3, .L35+40
 587 03b4 0C2093E5 		ldr	r2, [r3, #12]	@ float
 588 03b8 FC309FE5 		ldr	r3, .L35+52
 589 03bc 602083E5 		str	r2, [r3, #96]	@ float
 205:uart.c        **** 	        		my_this.pidZ.pid.ki=receiveParamDebug.ki_p;
 591              	.LM45:
 592 03c0 E8309FE5 		ldr	r3, .L35+40
 593 03c4 102093E5 		ldr	r2, [r3, #16]	@ float
 594 03c8 EC309FE5 		ldr	r3, .L35+52
 595 03cc 642083E5 		str	r2, [r3, #100]	@ float
 206:uart.c        **** 	        		my_this.pidVZ.pid.kp=receiveParamDebug.kp_v;
 597              	.LM46:
 598 03d0 D8309FE5 		ldr	r3, .L35+40
 599 03d4 042093E5 		ldr	r2, [r3, #4]	@ float
 600 03d8 DC309FE5 		ldr	r3, .L35+52
 601 03dc 142083E5 		str	r2, [r3, #20]	@ float
 207:uart.c        **** 	        		my_this.pidVZ.pid.ki=receiveParamDebug.ki_v;
 603              	.LM47:
 604 03e0 C8309FE5 		ldr	r3, .L35+40
 605 03e4 082093E5 		ldr	r2, [r3, #8]	@ float
 606 03e8 CC309FE5 		ldr	r3, .L35+52
 607 03ec 182083E5 		str	r2, [r3, #24]	@ float
 208:uart.c        **** 	        		my_setpoint.velocity.y=receiveParamDebug.set_velocity;
 609              	.LM48:
 610 03f0 B8309FE5 		ldr	r3, .L35+40
 611 03f4 1C2093E5 		ldr	r2, [r3, #28]	@ float
 612 03f8 C0309FE5 		ldr	r3, .L35+56
 613 03fc 102083E5 		str	r2, [r3, #16]	@ float
 614              	.L32:
 209:uart.c        **** 	        		//output_thrust=receiveParamDebug.thrust;
 210:uart.c        **** 	        		//if(receiveParamDebug.thrust==555)buzzer(1);
 211:uart.c        **** 	        	}
 212:uart.c        **** 	    		my_state.position.z=receiveParamDebug.z;
 616              	.LM49:
 617 0400 A8309FE5 		ldr	r3, .L35+40
 618 0404 142093E5 		ldr	r2, [r3, #20]	@ float
 619 0408 90309FE5 		ldr	r3, .L35+24
 620 040c 082083E5 		str	r2, [r3, #8]	@ float
 213:uart.c        **** 	    		my_state.velocity.z=receiveParamDebug.vz;
 622              	.LM50:
 623 0410 98309FE5 		ldr	r3, .L35+40
 624 0414 182093E5 		ldr	r2, [r3, #24]	@ float
 625 0418 80309FE5 		ldr	r3, .L35+24
 626 041c 142083E5 		str	r2, [r3, #20]	@ float
 214:uart.c        **** 	        	vicon_count++;
 628              	.LM51:
 629 0420 7C309FE5 		ldr	r3, .L35+28
 630 0424 003093E5 		ldr	r3, [r3, #0]
 631 0428 012083E2 		add	r2, r3, #1
 632 042c 70309FE5 		ldr	r3, .L35+28
 633 0430 002083E5 		str	r2, [r3, #0]
 215:uart.c        **** 				break;
 635              	.LM52:
 636 0434 0C0000EA 		b	.L12
 637              	.L28:
 216:uart.c        **** 			case PACKAGE_DEFINE_CMD:
 217:uart.c        **** 				memcpy(&receiveCmdData,
 639              	.LM53:
 640 0438 58309FE5 		ldr	r3, .L35+16
 641 043c 003093E5 		ldr	r3, [r3, #0]
 642 0440 0300A0E1 		mov	r0, r3
 643 0444 FEFFFFEB 		bl	getPackageLength
 644 0448 0030A0E1 		mov	r3, r0
 645 044c 0310A0E1 		mov	r1, r3
 646 0450 6C309FE5 		ldr	r3, .L35+60
 647 0454 38209FE5 		ldr	r2, .L35+12
 648 0458 01C0A0E1 		mov	ip, r1
 649 045c 0300A0E1 		mov	r0, r3
 650 0460 0210A0E1 		mov	r1, r2
 651 0464 0C20A0E1 		mov	r2, ip
 652 0468 FEFFFFEB 		bl	memcpy
 653              	.L12:
 218:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 219:uart.c        **** 				break;
 220:uart.c        **** 			default:
 221:uart.c        **** 				break;
 222:uart.c        **** 			}
 223:uart.c        ****         }
 224:uart.c        **** #endif
 225:uart.c        **** 
 226:uart.c        **** #ifdef PARAM_DEBUG_MODE
 227:uart.c        ****         if(my_receive(UART_rxdata,
 228:uart.c        ****         		my_buffer,
 229:uart.c        **** 				&receiveParamDebug,
 230:uart.c        **** 				1)){
 231:uart.c        ****         	if(receive_valid_data_flag==1||receiveParamDebug.kp_p!=0){
 232:uart.c        ****         		receive_valid_data_flag=1;
 233:uart.c        ****         		my_this.pidZ.pid.kp=receiveParamDebug.kp_p;
 234:uart.c        ****         		my_this.pidZ.pid.ki=receiveParamDebug.ki_p;
 235:uart.c        ****         		my_this.pidVZ.pid.kp=receiveParamDebug.kp_v;
 236:uart.c        ****         		my_this.pidVZ.pid.ki=receiveParamDebug.ki_v;
 237:uart.c        ****         		my_setpoint.velocity.y=receiveParamDebug.set_velocity;
 238:uart.c        ****         		//output_thrust=receiveParamDebug.thrust;
 239:uart.c        ****         		//if(receiveParamDebug.thrust==555)buzzer(1);
 240:uart.c        ****         	}
 241:uart.c        ****     		my_state.position.z=receiveParamDebug.z;
 242:uart.c        ****     		my_state.velocity.z=receiveParamDebug.vz;
 243:uart.c        ****         	vicon_count++;
 244:uart.c        ****         }
 245:uart.c        **** #endif
 246:uart.c        **** 
 247:uart.c        **** //        if (UART_syncstate==0)
 248:uart.c        **** //		{
 249:uart.c        **** //			if (UART_rxdata=='>') UART_syncstate++; else UART_syncstate=0;
 250:uart.c        **** //		}
 251:uart.c        **** //		else if (UART_syncstate==1)
 252:uart.c        **** //		{
 253:uart.c        **** //			if (UART_rxdata=='*') UART_syncstate++; else UART_syncstate=0;
 254:uart.c        **** //		}
 255:uart.c        **** //		else if (UART_syncstate==2)
 256:uart.c        **** //		{
 257:uart.c        **** //			if (UART_rxdata=='>') UART_syncstate++; else UART_syncstate=0;
 258:uart.c        **** //		}
 259:uart.c        **** //		else if (UART_syncstate==3)
 260:uart.c        **** //		{
 261:uart.c        **** //			//synchronized to start string => receive your data from here
 262:uart.c        **** //           UART_syncstate=0;
 263:uart.c        **** //        }
 264:uart.c        **** //		else UART_syncstate=0;
 265:uart.c        **** 
 266:uart.c        **** 
 267:uart.c        **** 
 268:uart.c        **** 
 269:uart.c        **** 
 270:uart.c        **** 
 271:uart.c        ****         break;
 272:uart.c        ****       case 3:
 273:uart.c        ****         // RLS interrupt
 274:uart.c        ****         break;
 275:uart.c        ****       case 6:
 276:uart.c        ****         // CTI interrupt
 277:uart.c        ****         break;
 278:uart.c        ****   }
 279:uart.c        ****   IDISABLE;
 280:uart.c        ****   VICVectAddr = 0;		// Acknowledge Interrupt
 655              	.LM54:
 656 046c 0030A0E3 		mov	r3, #0
 657 0470 FD3E43E2 		sub	r3, r3, #4048
 658 0474 0020A0E3 		mov	r2, #0
 659 0478 002083E5 		str	r2, [r3, #0]
 281:uart.c        ****  }
 661              	.LM55:
 662 047c 0CD04BE2 		sub	sp, fp, #12
 663 0480 00689DE8 		ldmfd	sp, {fp, sp, lr}
 664 0484 1EFF2FE1 		bx	lr
 665              	.L36:
 666              		.align	2
 667              	.L35:
 668 0488 00000000 		.word	trigger_transmission
 669 048c 00000000 		.word	transmission_running
 670 0490 00000000 		.word	my_buffer
 671 0494 00000000 		.word	allDataBuffer
 672 0498 00000000 		.word	pack_id
 673 049c 00000000 		.word	receivedViconData
 674 04a0 00000000 		.word	my_state
 675 04a4 00000000 		.word	vicon_count
 676 04a8 00000000 		.word	receiveDebugData
 677 04ac 00000000 		.word	vicon_tp
 678 04b0 00000000 		.word	receiveParamDebug
 679 04b4 00000000 		.word	receive_valid_data_flag
 680 04b8 00000000 		.word	0
 681 04bc 00000000 		.word	my_this
 682 04c0 00000000 		.word	my_setpoint
 683 04c4 00000000 		.word	receiveCmdData
 691              	.Lscope1:
 692              		.global	__udivsi3
 693              		.align	2
 696              		.global	UARTInitialize
 698              	UARTInitialize:
 282:uart.c        **** 
 283:uart.c        **** 
 284:uart.c        **** void UARTInitialize(unsigned int baud)
 285:uart.c        **** {
 700              	.LM56:
 701              		@ Function supports interworking.
 702              		@ args = 0, pretend = 0, frame = 8
 703              		@ frame_needed = 1, uses_anonymous_args = 0
 704 04c8 0DC0A0E1 		mov	ip, sp
 705 04cc 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 706 04d0 04B04CE2 		sub	fp, ip, #4
 707 04d4 08D04DE2 		sub	sp, sp, #8
 708 04d8 14000BE5 		str	r0, [fp, #-20]
 286:uart.c        ****   unsigned int divisor = peripheralClockFrequency() / (16 * baud);
 710              	.LM57:
 711 04dc FEFFFFEB 		bl	peripheralClockFrequency
 712 04e0 0020A0E1 		mov	r2, r0
 713 04e4 14301BE5 		ldr	r3, [fp, #-20]
 714 04e8 0332A0E1 		mov	r3, r3, asl #4
 715 04ec 0200A0E1 		mov	r0, r2
 716 04f0 0310A0E1 		mov	r1, r3
 717 04f4 FEFFFFEB 		bl	__udivsi3
 718 04f8 0030A0E1 		mov	r3, r0
 719 04fc 10300BE5 		str	r3, [fp, #-16]
 287:uart.c        **** 
 288:uart.c        ****   //UART0
 289:uart.c        ****   U0LCR = 0x83; /* 8 bit, 1 stop bit, no parity, enable DLAB */
 721              	.LM58:
 722 0500 0339A0E3 		mov	r3, #49152
 723 0504 CE3283E2 		add	r3, r3, #-536870900
 724 0508 8320A0E3 		mov	r2, #131
 725 050c 002083E5 		str	r2, [r3, #0]
 290:uart.c        ****   U0DLL = divisor & 0xFF;
 727              	.LM59:
 728 0510 0E32A0E3 		mov	r3, #-536870912
 729 0514 033983E2 		add	r3, r3, #49152
 730 0518 10201BE5 		ldr	r2, [fp, #-16]
 731 051c FF2002E2 		and	r2, r2, #255
 732 0520 002083E5 		str	r2, [r3, #0]
 291:uart.c        ****   U0DLM = (divisor >> 8) & 0xFF;
 734              	.LM60:
 735 0524 0329A0E3 		mov	r2, #49152
 736 0528 4E2282E2 		add	r2, r2, #-536870908
 737 052c 10301BE5 		ldr	r3, [fp, #-16]
 738 0530 2334A0E1 		mov	r3, r3, lsr #8
 739 0534 FF3003E2 		and	r3, r3, #255
 740 0538 003082E5 		str	r3, [r2, #0]
 292:uart.c        ****   U0LCR &= ~0x80; /* Disable DLAB */
 742              	.LM61:
 743 053c 0329A0E3 		mov	r2, #49152
 744 0540 CE2282E2 		add	r2, r2, #-536870900
 745 0544 0339A0E3 		mov	r3, #49152
 746 0548 CE3283E2 		add	r3, r3, #-536870900
 747 054c 003093E5 		ldr	r3, [r3, #0]
 748 0550 8030C3E3 		bic	r3, r3, #128
 749 0554 003082E5 		str	r3, [r2, #0]
 293:uart.c        ****   U0FCR = 1;
 751              	.LM62:
 752 0558 0339A0E3 		mov	r3, #49152
 753 055c 8E3283E2 		add	r3, r3, #-536870904
 754 0560 0120A0E3 		mov	r2, #1
 755 0564 002083E5 		str	r2, [r3, #0]
 294:uart.c        **** 
 295:uart.c        **** 
 296:uart.c        **** }
 757              	.LM63:
 758 0568 0CD04BE2 		sub	sp, fp, #12
 759 056c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 760 0570 1EFF2FE1 		bx	lr
 765              	.Lscope2:
 766              		.align	2
 769              		.global	UART1Initialize
 771              	UART1Initialize:
 297:uart.c        **** 
 298:uart.c        **** void UART1Initialize(unsigned int baud)
 299:uart.c        **** {
 773              	.LM64:
 774              		@ Function supports interworking.
 775              		@ args = 0, pretend = 0, frame = 8
 776              		@ frame_needed = 1, uses_anonymous_args = 0
 777 0574 0DC0A0E1 		mov	ip, sp
 778 0578 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 779 057c 04B04CE2 		sub	fp, ip, #4
 780 0580 08D04DE2 		sub	sp, sp, #8
 781 0584 14000BE5 		str	r0, [fp, #-20]
 300:uart.c        ****   unsigned int divisor = peripheralClockFrequency() / (16 * baud);
 783              	.LM65:
 784 0588 FEFFFFEB 		bl	peripheralClockFrequency
 785 058c 0020A0E1 		mov	r2, r0
 786 0590 14301BE5 		ldr	r3, [fp, #-20]
 787 0594 0332A0E1 		mov	r3, r3, asl #4
 788 0598 0200A0E1 		mov	r0, r2
 789 059c 0310A0E1 		mov	r1, r3
 790 05a0 FEFFFFEB 		bl	__udivsi3
 791 05a4 0030A0E1 		mov	r3, r0
 792 05a8 10300BE5 		str	r3, [fp, #-16]
 301:uart.c        **** //UART1
 302:uart.c        ****   U1LCR = 0x83; /* 8 bit, 1 stop bit, no parity, enable DLAB */
 794              	.LM66:
 795 05ac CE32A0E3 		mov	r3, #-536870900
 796 05b0 013883E2 		add	r3, r3, #65536
 797 05b4 8320A0E3 		mov	r2, #131
 798 05b8 002083E5 		str	r2, [r3, #0]
 303:uart.c        ****   U1DLL = divisor & 0xFF;
 800              	.LM67:
 801 05bc 0E32A0E3 		mov	r3, #-536870912
 802 05c0 013883E2 		add	r3, r3, #65536
 803 05c4 10201BE5 		ldr	r2, [fp, #-16]
 804 05c8 FF2002E2 		and	r2, r2, #255
 805 05cc 002083E5 		str	r2, [r3, #0]
 304:uart.c        ****   U1DLM = (divisor >> 8) & 0xFF;
 807              	.LM68:
 808 05d0 4E22A0E3 		mov	r2, #-536870908
 809 05d4 012882E2 		add	r2, r2, #65536
 810 05d8 10301BE5 		ldr	r3, [fp, #-16]
 811 05dc 2334A0E1 		mov	r3, r3, lsr #8
 812 05e0 FF3003E2 		and	r3, r3, #255
 813 05e4 003082E5 		str	r3, [r2, #0]
 305:uart.c        ****   U1LCR &= ~0x80; /* Disable DLAB */
 815              	.LM69:
 816 05e8 CE22A0E3 		mov	r2, #-536870900
 817 05ec 012882E2 		add	r2, r2, #65536
 818 05f0 CE32A0E3 		mov	r3, #-536870900
 819 05f4 013883E2 		add	r3, r3, #65536
 820 05f8 003093E5 		ldr	r3, [r3, #0]
 821 05fc 8030C3E3 		bic	r3, r3, #128
 822 0600 003082E5 		str	r3, [r2, #0]
 306:uart.c        ****   U1FCR = 1;
 824              	.LM70:
 825 0604 8E32A0E3 		mov	r3, #-536870904
 826 0608 013883E2 		add	r3, r3, #65536
 827 060c 0120A0E3 		mov	r2, #1
 828 0610 002083E5 		str	r2, [r3, #0]
 307:uart.c        **** }
 830              	.LM71:
 831 0614 0CD04BE2 		sub	sp, fp, #12
 832 0618 00689DE8 		ldmfd	sp, {fp, sp, lr}
 833 061c 1EFF2FE1 		bx	lr
 838              	.Lscope3:
 839              		.align	2
 842              		.global	UARTWriteChar
 844              	UARTWriteChar:
 308:uart.c        **** 
 309:uart.c        **** 
 310:uart.c        **** //Write to UART0
 311:uart.c        **** void UARTWriteChar(unsigned char ch)
 312:uart.c        **** {
 846              	.LM72:
 847              		@ Function supports interworking.
 848              		@ args = 0, pretend = 0, frame = 4
 849              		@ frame_needed = 1, uses_anonymous_args = 0
 850 0620 0DC0A0E1 		mov	ip, sp
 851 0624 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 852 0628 04B04CE2 		sub	fp, ip, #4
 853 062c 04D04DE2 		sub	sp, sp, #4
 854 0630 0030A0E1 		mov	r3, r0
 855 0634 10304BE5 		strb	r3, [fp, #-16]
 856              	.L42:
 313:uart.c        ****   while ((U0LSR & 0x20) == 0);
 858              	.LM73:
 859 0638 0E32A0E3 		mov	r3, #-536870912
 860 063c 033983E2 		add	r3, r3, #49152
 861 0640 143083E2 		add	r3, r3, #20
 862 0644 003093E5 		ldr	r3, [r3, #0]
 863 0648 203003E2 		and	r3, r3, #32
 864 064c 000053E3 		cmp	r3, #0
 865 0650 F8FFFF0A 		beq	.L42
 314:uart.c        ****   U0THR = ch;
 867              	.LM74:
 868 0654 0E32A0E3 		mov	r3, #-536870912
 869 0658 033983E2 		add	r3, r3, #49152
 870 065c 10205BE5 		ldrb	r2, [fp, #-16]	@ zero_extendqisi2
 871 0660 002083E5 		str	r2, [r3, #0]
 315:uart.c        **** }
 873              	.LM75:
 874 0664 0CD04BE2 		sub	sp, fp, #12
 875 0668 00689DE8 		ldmfd	sp, {fp, sp, lr}
 876 066c 1EFF2FE1 		bx	lr
 878              	.Lscope4:
 879              		.align	2
 882              		.global	UART1WriteChar
 884              	UART1WriteChar:
 316:uart.c        **** //Write to UART1
 317:uart.c        **** void UART1WriteChar(unsigned char ch)
 318:uart.c        **** {
 886              	.LM76:
 887              		@ Function supports interworking.
 888              		@ args = 0, pretend = 0, frame = 4
 889              		@ frame_needed = 1, uses_anonymous_args = 0
 890 0670 0DC0A0E1 		mov	ip, sp
 891 0674 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 892 0678 04B04CE2 		sub	fp, ip, #4
 893 067c 04D04DE2 		sub	sp, sp, #4
 894 0680 0030A0E1 		mov	r3, r0
 895 0684 10304BE5 		strb	r3, [fp, #-16]
 896              	.L46:
 319:uart.c        ****   while ((U1LSR & 0x20) == 0);
 898              	.LM77:
 899 0688 0E32A0E3 		mov	r3, #-536870912
 900 068c 013883E2 		add	r3, r3, #65536
 901 0690 143083E2 		add	r3, r3, #20
 902 0694 003093E5 		ldr	r3, [r3, #0]
 903 0698 203003E2 		and	r3, r3, #32
 904 069c 000053E3 		cmp	r3, #0
 905 06a0 F8FFFF0A 		beq	.L46
 320:uart.c        ****   U1THR = ch;
 907              	.LM78:
 908 06a4 0E32A0E3 		mov	r3, #-536870912
 909 06a8 013883E2 		add	r3, r3, #65536
 910 06ac 10205BE5 		ldrb	r2, [fp, #-16]	@ zero_extendqisi2
 911 06b0 002083E5 		str	r2, [r3, #0]
 321:uart.c        **** }
 913              	.LM79:
 914 06b4 0CD04BE2 		sub	sp, fp, #12
 915 06b8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 916 06bc 1EFF2FE1 		bx	lr
 918              	.Lscope5:
 919              		.align	2
 921              		.global	UARTReadChar
 923              	UARTReadChar:
 322:uart.c        **** 
 323:uart.c        **** unsigned char UARTReadChar(void)
 324:uart.c        **** {
 925              	.LM80:
 926              		@ Function supports interworking.
 927              		@ args = 0, pretend = 0, frame = 0
 928              		@ frame_needed = 1, uses_anonymous_args = 0
 929 06c0 0DC0A0E1 		mov	ip, sp
 930 06c4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 931 06c8 04B04CE2 		sub	fp, ip, #4
 932              	.L50:
 325:uart.c        ****   while ((U0LSR & 0x01) == 0);
 934              	.LM81:
 935 06cc 0E32A0E3 		mov	r3, #-536870912
 936 06d0 033983E2 		add	r3, r3, #49152
 937 06d4 143083E2 		add	r3, r3, #20
 938 06d8 003093E5 		ldr	r3, [r3, #0]
 939 06dc 013003E2 		and	r3, r3, #1
 940 06e0 000053E3 		cmp	r3, #0
 941 06e4 F8FFFF0A 		beq	.L50
 326:uart.c        ****   return U0RBR;
 943              	.LM82:
 944 06e8 0E32A0E3 		mov	r3, #-536870912
 945 06ec 033983E2 		add	r3, r3, #49152
 946 06f0 003093E5 		ldr	r3, [r3, #0]
 947 06f4 FF3003E2 		and	r3, r3, #255
 327:uart.c        **** }
 949              	.LM83:
 950 06f8 0300A0E1 		mov	r0, r3
 951 06fc 0CD04BE2 		sub	sp, fp, #12
 952 0700 00689DE8 		ldmfd	sp, {fp, sp, lr}
 953 0704 1EFF2FE1 		bx	lr
 955              	.Lscope6:
 956              		.align	2
 958              		.global	UART1ReadChar
 960              	UART1ReadChar:
 328:uart.c        **** 
 329:uart.c        **** unsigned char UART1ReadChar(void)
 330:uart.c        **** {
 962              	.LM84:
 963              		@ Function supports interworking.
 964              		@ args = 0, pretend = 0, frame = 0
 965              		@ frame_needed = 1, uses_anonymous_args = 0
 966 0708 0DC0A0E1 		mov	ip, sp
 967 070c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 968 0710 04B04CE2 		sub	fp, ip, #4
 969              	.L54:
 331:uart.c        ****   while ((U1LSR & 0x01) == 0);
 971              	.LM85:
 972 0714 0E32A0E3 		mov	r3, #-536870912
 973 0718 013883E2 		add	r3, r3, #65536
 974 071c 143083E2 		add	r3, r3, #20
 975 0720 003093E5 		ldr	r3, [r3, #0]
 976 0724 013003E2 		and	r3, r3, #1
 977 0728 000053E3 		cmp	r3, #0
 978 072c F8FFFF0A 		beq	.L54
 332:uart.c        ****   return U1RBR;
 980              	.LM86:
 981 0730 0E32A0E3 		mov	r3, #-536870912
 982 0734 013883E2 		add	r3, r3, #65536
 983 0738 003093E5 		ldr	r3, [r3, #0]
 984 073c FF3003E2 		and	r3, r3, #255
 333:uart.c        **** }
 986              	.LM87:
 987 0740 0300A0E1 		mov	r0, r3
 988 0744 0CD04BE2 		sub	sp, fp, #12
 989 0748 00689DE8 		ldmfd	sp, {fp, sp, lr}
 990 074c 1EFF2FE1 		bx	lr
 992              	.Lscope7:
 993              		.align	2
 996              		.global	__putchar
 998              	__putchar:
 334:uart.c        **** 
 335:uart.c        **** void __putchar(int ch)
 336:uart.c        **** {
 1000              	.LM88:
 1001              		@ Function supports interworking.
 1002              		@ args = 0, pretend = 0, frame = 4
 1003              		@ frame_needed = 1, uses_anonymous_args = 0
 1004 0750 0DC0A0E1 		mov	ip, sp
 1005 0754 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1006 0758 04B04CE2 		sub	fp, ip, #4
 1007 075c 04D04DE2 		sub	sp, sp, #4
 1008 0760 10000BE5 		str	r0, [fp, #-16]
 337:uart.c        ****   if (ch == '\n')
 1010              	.LM89:
 1011 0764 10301BE5 		ldr	r3, [fp, #-16]
 1012 0768 0A0053E3 		cmp	r3, #10
 1013 076c 0100001A 		bne	.L58
 338:uart.c        ****     UARTWriteChar('\r');
 1015              	.LM90:
 1016 0770 0D00A0E3 		mov	r0, #13
 1017 0774 FEFFFFEB 		bl	UARTWriteChar
 1018              	.L58:
 339:uart.c        ****   UARTWriteChar(ch);
 1020              	.LM91:
 1021 0778 10301BE5 		ldr	r3, [fp, #-16]
 1022 077c FF3003E2 		and	r3, r3, #255
 1023 0780 0300A0E1 		mov	r0, r3
 1024 0784 FEFFFFEB 		bl	UARTWriteChar
 340:uart.c        **** }
 1026              	.LM92:
 1027 0788 0CD04BE2 		sub	sp, fp, #12
 1028 078c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1029 0790 1EFF2FE1 		bx	lr
 1031              	.Lscope8:
 1032              		.align	2
 1036              		.global	UART_send
 1038              	UART_send:
 341:uart.c        **** 
 342:uart.c        **** void UART_send(char *buffer, unsigned char length)
 343:uart.c        **** {
 1040              	.LM93:
 1041              		@ Function supports interworking.
 1042              		@ args = 0, pretend = 0, frame = 12
 1043              		@ frame_needed = 1, uses_anonymous_args = 0
 1044 0794 0DC0A0E1 		mov	ip, sp
 1045 0798 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1046 079c 04B04CE2 		sub	fp, ip, #4
 1047 07a0 0CD04DE2 		sub	sp, sp, #12
 1048 07a4 14000BE5 		str	r0, [fp, #-20]
 1049 07a8 0130A0E1 		mov	r3, r1
 1050 07ac 18304BE5 		strb	r3, [fp, #-24]
 344:uart.c        ****   unsigned char cnt=0;
 1052              	.LM94:
 1053 07b0 0030A0E3 		mov	r3, #0
 1054 07b4 0D304BE5 		strb	r3, [fp, #-13]
 1055              	.L62:
 345:uart.c        ****   while (!(U0LSR & 0x20)); //wait until U0THR and U0TSR are both empty
 1057              	.LM95:
 1058 07b8 0E32A0E3 		mov	r3, #-536870912
 1059 07bc 033983E2 		add	r3, r3, #49152
 1060 07c0 143083E2 		add	r3, r3, #20
 1061 07c4 003093E5 		ldr	r3, [r3, #0]
 1062 07c8 203003E2 		and	r3, r3, #32
 1063 07cc 000053E3 		cmp	r3, #0
 1064 07d0 F8FFFF0A 		beq	.L62
 346:uart.c        ****   while(length--)
 1066              	.LM96:
 1067 07d4 140000EA 		b	.L69
 1068              	.L65:
 347:uart.c        ****   {
 348:uart.c        ****     U0THR = buffer[cnt++];
 1070              	.LM97:
 1071 07d8 0E22A0E3 		mov	r2, #-536870912
 1072 07dc 032982E2 		add	r2, r2, #49152
 1073 07e0 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1074 07e4 0310A0E1 		mov	r1, r3
 1075 07e8 14301BE5 		ldr	r3, [fp, #-20]
 1076 07ec 033081E0 		add	r3, r1, r3
 1077 07f0 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1078 07f4 003082E5 		str	r3, [r2, #0]
 1079 07f8 0D305BE5 		ldrb	r3, [fp, #-13]
 1080 07fc 013083E2 		add	r3, r3, #1
 1081 0800 0D304BE5 		strb	r3, [fp, #-13]
 349:uart.c        ****     if(cnt>15)
 1083              	.LM98:
 1084 0804 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1085 0808 0F0053E3 		cmp	r3, #15
 1086 080c 0600009A 		bls	.L64
 1087              	.L66:
 350:uart.c        ****     {
 351:uart.c        ****       while (!(U0LSR & 0x20)); //wait until U0THR is empty
 1089              	.LM99:
 1090 0810 0E32A0E3 		mov	r3, #-536870912
 1091 0814 033983E2 		add	r3, r3, #49152
 1092 0818 143083E2 		add	r3, r3, #20
 1093 081c 003093E5 		ldr	r3, [r3, #0]
 1094 0820 203003E2 		and	r3, r3, #32
 1095 0824 000053E3 		cmp	r3, #0
 1096 0828 F8FFFF0A 		beq	.L66
 1097              	.L64:
 1098              	.L69:
 346:uart.c        ****   while(length--)
 1100              	.LM100:
 1101 082c 18305BE5 		ldrb	r3, [fp, #-24]
 1102 0830 013043E2 		sub	r3, r3, #1
 1103 0834 18304BE5 		strb	r3, [fp, #-24]
 1104 0838 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1105 083c FF0053E3 		cmp	r3, #255
 1106 0840 E4FFFF1A 		bne	.L65
 352:uart.c        ****     }
 353:uart.c        ****   }
 354:uart.c        **** }
 1108              	.LM101:
 1109 0844 0CD04BE2 		sub	sp, fp, #12
 1110 0848 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1111 084c 1EFF2FE1 		bx	lr
 1116              	.Lscope9:
 1117              		.align	2
 1121              		.global	UART1_send
 1123              	UART1_send:
 355:uart.c        **** 
 356:uart.c        **** void UART1_send(unsigned char *buffer, unsigned char length)
 357:uart.c        **** {
 1125              	.LM102:
 1126              		@ Function supports interworking.
 1127              		@ args = 0, pretend = 0, frame = 12
 1128              		@ frame_needed = 1, uses_anonymous_args = 0
 1129 0850 0DC0A0E1 		mov	ip, sp
 1130 0854 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1131 0858 04B04CE2 		sub	fp, ip, #4
 1132 085c 0CD04DE2 		sub	sp, sp, #12
 1133 0860 14000BE5 		str	r0, [fp, #-20]
 1134 0864 0130A0E1 		mov	r3, r1
 1135 0868 18304BE5 		strb	r3, [fp, #-24]
 358:uart.c        ****   unsigned char cnt=0;
 1137              	.LM103:
 1138 086c 0030A0E3 		mov	r3, #0
 1139 0870 0D304BE5 		strb	r3, [fp, #-13]
 359:uart.c        ****   while(length--)
 1141              	.LM104:
 1142 0874 110000EA 		b	.L71
 1143              	.L72:
 360:uart.c        ****   {
 361:uart.c        ****     while (!(U1LSR & 0x20)); //wait until U1THR is empty
 1145              	.LM105:
 1146 0878 0E32A0E3 		mov	r3, #-536870912
 1147 087c 013883E2 		add	r3, r3, #65536
 1148 0880 143083E2 		add	r3, r3, #20
 1149 0884 003093E5 		ldr	r3, [r3, #0]
 1150 0888 203003E2 		and	r3, r3, #32
 1151 088c 000053E3 		cmp	r3, #0
 1152 0890 F8FFFF0A 		beq	.L72
 362:uart.c        ****     U1THR = buffer[cnt++];
 1154              	.LM106:
 1155 0894 0E22A0E3 		mov	r2, #-536870912
 1156 0898 012882E2 		add	r2, r2, #65536
 1157 089c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1158 08a0 0310A0E1 		mov	r1, r3
 1159 08a4 14301BE5 		ldr	r3, [fp, #-20]
 1160 08a8 033081E0 		add	r3, r1, r3
 1161 08ac 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1162 08b0 003082E5 		str	r3, [r2, #0]
 1163 08b4 0D305BE5 		ldrb	r3, [fp, #-13]
 1164 08b8 013083E2 		add	r3, r3, #1
 1165 08bc 0D304BE5 		strb	r3, [fp, #-13]
 1166              	.L71:
 359:uart.c        ****   while(length--)
 1168              	.LM107:
 1169 08c0 18305BE5 		ldrb	r3, [fp, #-24]
 1170 08c4 013043E2 		sub	r3, r3, #1
 1171 08c8 18304BE5 		strb	r3, [fp, #-24]
 1172 08cc 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1173 08d0 FF0053E3 		cmp	r3, #255
 1174 08d4 E7FFFF1A 		bne	.L72
 363:uart.c        ****   }
 364:uart.c        **** }
 1176              	.LM108:
 1177 08d8 0CD04BE2 		sub	sp, fp, #12
 1178 08dc 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1179 08e0 1EFF2FE1 		bx	lr
 1184              	.Lscope10:
 1185              		.align	2
 1187              		.global	UART_send_ringbuffer
 1189              	UART_send_ringbuffer:
 365:uart.c        **** 
 366:uart.c        **** 
 367:uart.c        **** void UART_send_ringbuffer(void)
 368:uart.c        **** {
 1191              	.LM109:
 1192              		@ Function supports interworking.
 1193              		@ args = 0, pretend = 0, frame = 4
 1194              		@ frame_needed = 1, uses_anonymous_args = 0
 1195 08e4 0DC0A0E1 		mov	ip, sp
 1196 08e8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1197 08ec 04B04CE2 		sub	fp, ip, #4
 1198 08f0 04D04DE2 		sub	sp, sp, #4
 369:uart.c        ****   unsigned char t;
 370:uart.c        ****   if(!transmission_running)
 1200              	.LM110:
 1201 08f4 4C309FE5 		ldr	r3, .L81
 1202 08f8 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1203 08fc 000053E3 		cmp	r3, #0
 1204 0900 0D00001A 		bne	.L80
 371:uart.c        ****   {
 372:uart.c        ****     if(ringbuffer(RBREAD, &t, 1))
 1206              	.LM111:
 1207 0904 0D304BE2 		sub	r3, fp, #13
 1208 0908 0000A0E3 		mov	r0, #0
 1209 090c 0310A0E1 		mov	r1, r3
 1210 0910 0120A0E3 		mov	r2, #1
 1211 0914 FEFFFFEB 		bl	ringbuffer
 1212 0918 0030A0E1 		mov	r3, r0
 1213 091c 000053E3 		cmp	r3, #0
 1214 0920 0500000A 		beq	.L80
 373:uart.c        ****     {
 374:uart.c        ****       transmission_running=1;
 1216              	.LM112:
 1217 0924 1C209FE5 		ldr	r2, .L81
 1218 0928 0130A0E3 		mov	r3, #1
 1219 092c 0030C2E5 		strb	r3, [r2, #0]
 375:uart.c        ****       UARTWriteChar(t);
 1221              	.LM113:
 1222 0930 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1223 0934 0300A0E1 		mov	r0, r3
 1224 0938 FEFFFFEB 		bl	UARTWriteChar
 1225              	.L80:
 376:uart.c        ****     }
 377:uart.c        ****   }
 378:uart.c        **** }
 1227              	.LM114:
 1228 093c 0CD04BE2 		sub	sp, fp, #12
 1229 0940 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1230 0944 1EFF2FE1 		bx	lr
 1231              	.L82:
 1232              		.align	2
 1233              	.L81:
 1234 0948 00000000 		.word	transmission_running
 1239              	.Lscope11:
 1240              		.align	2
 1242              		.global	UART1_send_ringbuffer
 1244              	UART1_send_ringbuffer:
 379:uart.c        **** 
 380:uart.c        **** void UART1_send_ringbuffer(void)
 381:uart.c        **** {
 1246              	.LM115:
 1247              		@ Function supports interworking.
 1248              		@ args = 0, pretend = 0, frame = 4
 1249              		@ frame_needed = 1, uses_anonymous_args = 0
 1250 094c 0DC0A0E1 		mov	ip, sp
 1251 0950 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1252 0954 04B04CE2 		sub	fp, ip, #4
 1253 0958 04D04DE2 		sub	sp, sp, #4
 382:uart.c        ****   unsigned char t;
 383:uart.c        ****   if(!transmission1_running)
 1255              	.LM116:
 1256 095c 4C309FE5 		ldr	r3, .L88
 1257 0960 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1258 0964 000053E3 		cmp	r3, #0
 1259 0968 0D00001A 		bne	.L87
 384:uart.c        ****   {
 385:uart.c        ****     if(ringbuffer1(RBREAD, &t, 1))
 1261              	.LM117:
 1262 096c 0D304BE2 		sub	r3, fp, #13
 1263 0970 0000A0E3 		mov	r0, #0
 1264 0974 0310A0E1 		mov	r1, r3
 1265 0978 0120A0E3 		mov	r2, #1
 1266 097c FEFFFFEB 		bl	ringbuffer1
 1267 0980 0030A0E1 		mov	r3, r0
 1268 0984 000053E3 		cmp	r3, #0
 1269 0988 0500000A 		beq	.L87
 386:uart.c        ****     {
 387:uart.c        ****       transmission1_running=1;
 1271              	.LM118:
 1272 098c 1C209FE5 		ldr	r2, .L88
 1273 0990 0130A0E3 		mov	r3, #1
 1274 0994 0030C2E5 		strb	r3, [r2, #0]
 388:uart.c        ****       UART1WriteChar(t);
 1276              	.LM119:
 1277 0998 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1278 099c 0300A0E1 		mov	r0, r3
 1279 09a0 FEFFFFEB 		bl	UART1WriteChar
 1280              	.L87:
 389:uart.c        ****     }
 390:uart.c        ****   }
 391:uart.c        **** }
 1282              	.LM120:
 1283 09a4 0CD04BE2 		sub	sp, fp, #12
 1284 09a8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1285 09ac 1EFF2FE1 		bx	lr
 1286              	.L89:
 1287              		.align	2
 1288              	.L88:
 1289 09b0 00000000 		.word	transmission1_running
 1294              	.Lscope12:
 1295              		.align	2
 1300              		.global	UART_SendPacket
 1302              	UART_SendPacket:
 392:uart.c        **** 
 393:uart.c        **** void UART_SendPacket(void *data, unsigned short count, unsigned char packetdescriptor) //example to
 394:uart.c        **** {
 1304              	.LM121:
 1305              		@ Function supports interworking.
 1306              		@ args = 0, pretend = 0, frame = 20
 1307              		@ frame_needed = 1, uses_anonymous_args = 0
 1308 09b4 0DC0A0E1 		mov	ip, sp
 1309 09b8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1310 09bc 04B04CE2 		sub	fp, ip, #4
 1311 09c0 14D04DE2 		sub	sp, sp, #20
 1312 09c4 18000BE5 		str	r0, [fp, #-24]
 1313 09c8 0130A0E1 		mov	r3, r1
 1314 09cc BC314BE1 		strh	r3, [fp, #-28]	@ movhi
 1315 09d0 0230A0E1 		mov	r3, r2
 1316 09d4 20304BE5 		strb	r3, [fp, #-32]
 395:uart.c        ****   unsigned short crc;
 396:uart.c        ****   int state;
 397:uart.c        ****       state=ringbuffer(RBWRITE, startstring, 3);
 1318              	.LM122:
 1319 09d8 0100A0E3 		mov	r0, #1
 1320 09dc C0109FE5 		ldr	r1, .L92
 1321 09e0 0320A0E3 		mov	r2, #3
 1322 09e4 FEFFFFEB 		bl	ringbuffer
 1323 09e8 0030A0E1 		mov	r3, r0
 1324 09ec 10300BE5 		str	r3, [fp, #-16]
 398:uart.c        ****       state=ringbuffer(RBWRITE, (unsigned char *) &count, 2);
 1326              	.LM123:
 1327 09f0 1C304BE2 		sub	r3, fp, #28
 1328 09f4 0100A0E3 		mov	r0, #1
 1329 09f8 0310A0E1 		mov	r1, r3
 1330 09fc 0220A0E3 		mov	r2, #2
 1331 0a00 FEFFFFEB 		bl	ringbuffer
 1332 0a04 0030A0E1 		mov	r3, r0
 1333 0a08 10300BE5 		str	r3, [fp, #-16]
 399:uart.c        ****       state=ringbuffer(RBWRITE, &packetdescriptor, 1);
 1335              	.LM124:
 1336 0a0c 20304BE2 		sub	r3, fp, #32
 1337 0a10 0100A0E3 		mov	r0, #1
 1338 0a14 0310A0E1 		mov	r1, r3
 1339 0a18 0120A0E3 		mov	r2, #1
 1340 0a1c FEFFFFEB 		bl	ringbuffer
 1341 0a20 0030A0E1 		mov	r3, r0
 1342 0a24 10300BE5 		str	r3, [fp, #-16]
 400:uart.c        ****       state=ringbuffer(RBWRITE, data, count);
 1344              	.LM125:
 1345 0a28 18201BE5 		ldr	r2, [fp, #-24]
 1346 0a2c BC315BE1 		ldrh	r3, [fp, #-28]
 1347 0a30 0100A0E3 		mov	r0, #1
 1348 0a34 0210A0E1 		mov	r1, r2
 1349 0a38 0320A0E1 		mov	r2, r3
 1350 0a3c FEFFFFEB 		bl	ringbuffer
 1351 0a40 0030A0E1 		mov	r3, r0
 1352 0a44 10300BE5 		str	r3, [fp, #-16]
 401:uart.c        ****                 crc=crc16(data,count);
 1354              	.LM126:
 1355 0a48 BC315BE1 		ldrh	r3, [fp, #-28]
 1356 0a4c 18001BE5 		ldr	r0, [fp, #-24]
 1357 0a50 0310A0E1 		mov	r1, r3
 1358 0a54 FEFFFFEB 		bl	crc16
 1359 0a58 0030A0E1 		mov	r3, r0
 1360 0a5c B2314BE1 		strh	r3, [fp, #-18]	@ movhi
 402:uart.c        ****       state=ringbuffer(RBWRITE, (unsigned char *) &crc, 2);
 1362              	.LM127:
 1363 0a60 12304BE2 		sub	r3, fp, #18
 1364 0a64 0100A0E3 		mov	r0, #1
 1365 0a68 0310A0E1 		mov	r1, r3
 1366 0a6c 0220A0E3 		mov	r2, #2
 1367 0a70 FEFFFFEB 		bl	ringbuffer
 1368 0a74 0030A0E1 		mov	r3, r0
 1369 0a78 10300BE5 		str	r3, [fp, #-16]
 403:uart.c        ****       state=ringbuffer(RBWRITE, stopstring, 3);
 1371              	.LM128:
 1372 0a7c 0100A0E3 		mov	r0, #1
 1373 0a80 20109FE5 		ldr	r1, .L92+4
 1374 0a84 0320A0E3 		mov	r2, #3
 1375 0a88 FEFFFFEB 		bl	ringbuffer
 1376 0a8c 0030A0E1 		mov	r3, r0
 1377 0a90 10300BE5 		str	r3, [fp, #-16]
 404:uart.c        ****       UART_send_ringbuffer();
 1379              	.LM129:
 1380 0a94 FEFFFFEB 		bl	UART_send_ringbuffer
 405:uart.c        **** }
 1382              	.LM130:
 1383 0a98 0CD04BE2 		sub	sp, fp, #12
 1384 0a9c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1385 0aa0 1EFF2FE1 		bx	lr
 1386              	.L93:
 1387              		.align	2
 1388              	.L92:
 1389 0aa4 00000000 		.word	startstring
 1390 0aa8 00000000 		.word	stopstring
 1396              	.Lscope13:
 1397              		.align	2
 1401              		.global	crc_update
 1403              	crc_update:
 406:uart.c        **** 
 407:uart.c        **** //example CRC16 function
 408:uart.c        **** unsigned short crc_update (unsigned short crc, unsigned char data)
 409:uart.c        ****      {
 1405              	.LM131:
 1406              		@ Function supports interworking.
 1407              		@ args = 0, pretend = 0, frame = 8
 1408              		@ frame_needed = 1, uses_anonymous_args = 0
 1409 0aac 0DC0A0E1 		mov	ip, sp
 1410 0ab0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1411 0ab4 04B04CE2 		sub	fp, ip, #4
 1412 0ab8 08D04DE2 		sub	sp, sp, #8
 1413 0abc 0030A0E1 		mov	r3, r0
 1414 0ac0 0120A0E1 		mov	r2, r1
 1415 0ac4 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 1416 0ac8 0230A0E1 		mov	r3, r2
 1417 0acc 14304BE5 		strb	r3, [fp, #-20]
 410:uart.c        ****          data ^= (crc & 0xff);
 1419              	.LM132:
 1420 0ad0 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1421 0ad4 FF3003E2 		and	r3, r3, #255
 1422 0ad8 FF3003E2 		and	r3, r3, #255
 1423 0adc 14205BE5 		ldrb	r2, [fp, #-20]	@ zero_extendqisi2
 1424 0ae0 0310A0E1 		mov	r1, r3
 1425 0ae4 0230A0E1 		mov	r3, r2
 1426 0ae8 033021E0 		eor	r3, r1, r3
 1427 0aec FF3003E2 		and	r3, r3, #255
 1428 0af0 14304BE5 		strb	r3, [fp, #-20]
 411:uart.c        ****          data ^= data << 4;
 1430              	.LM133:
 1431 0af4 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1432 0af8 0332A0E1 		mov	r3, r3, asl #4
 1433 0afc FF3003E2 		and	r3, r3, #255
 1434 0b00 14205BE5 		ldrb	r2, [fp, #-20]	@ zero_extendqisi2
 1435 0b04 0310A0E1 		mov	r1, r3
 1436 0b08 0230A0E1 		mov	r3, r2
 1437 0b0c 033021E0 		eor	r3, r1, r3
 1438 0b10 FF3003E2 		and	r3, r3, #255
 1439 0b14 14304BE5 		strb	r3, [fp, #-20]
 412:uart.c        **** 
 413:uart.c        ****          return ((((unsigned short )data << 8) | ((crc>>8)&0xff)) ^ (unsigned char )(data >> 4)
 1441              	.LM134:
 1442 0b18 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1443 0b1c 0334A0E1 		mov	r3, r3, asl #8
 1444 0b20 0338A0E1 		mov	r3, r3, asl #16
 1445 0b24 2328A0E1 		mov	r2, r3, lsr #16
 1446 0b28 B0315BE1 		ldrh	r3, [fp, #-16]
 1447 0b2c 2334A0E1 		mov	r3, r3, lsr #8
 1448 0b30 0338A0E1 		mov	r3, r3, asl #16
 1449 0b34 2338A0E1 		mov	r3, r3, lsr #16
 1450 0b38 0338A0E1 		mov	r3, r3, asl #16
 1451 0b3c 2338A0E1 		mov	r3, r3, lsr #16
 1452 0b40 FF3003E2 		and	r3, r3, #255
 1453 0b44 033082E1 		orr	r3, r2, r3
 1454 0b48 0338A0E1 		mov	r3, r3, asl #16
 1455 0b4c 2328A0E1 		mov	r2, r3, lsr #16
 1456 0b50 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1457 0b54 2332A0E1 		mov	r3, r3, lsr #4
 1458 0b58 FF3003E2 		and	r3, r3, #255
 1459 0b5c 033022E0 		eor	r3, r2, r3
 1460 0b60 0338A0E1 		mov	r3, r3, asl #16
 1461 0b64 2328A0E1 		mov	r2, r3, lsr #16
 1462 0b68 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1463 0b6c 8331A0E1 		mov	r3, r3, asl #3
 1464 0b70 0338A0E1 		mov	r3, r3, asl #16
 1465 0b74 2338A0E1 		mov	r3, r3, lsr #16
 1466 0b78 033022E0 		eor	r3, r2, r3
 1467 0b7c 0338A0E1 		mov	r3, r3, asl #16
 1468 0b80 2338A0E1 		mov	r3, r3, lsr #16
 1469 0b84 0338A0E1 		mov	r3, r3, asl #16
 1470 0b88 2338A0E1 		mov	r3, r3, lsr #16
 414:uart.c        ****                  ^ ((unsigned short )data << 3));
 415:uart.c        ****      }
 1472              	.LM135:
 1473 0b8c 0300A0E1 		mov	r0, r3
 1474 0b90 0CD04BE2 		sub	sp, fp, #12
 1475 0b94 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1476 0b98 1EFF2FE1 		bx	lr
 1478              	.Lscope14:
 1479              		.align	2
 1483              		.global	crc16
 1485              	crc16:
 416:uart.c        **** 
 417:uart.c        ****  unsigned short crc16(void* data, unsigned short cnt)
 418:uart.c        ****  {
 1487              	.LM136:
 1488              		@ Function supports interworking.
 1489              		@ args = 0, pretend = 0, frame = 20
 1490              		@ frame_needed = 1, uses_anonymous_args = 0
 1491 0b9c 0DC0A0E1 		mov	ip, sp
 1492 0ba0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1493 0ba4 04B04CE2 		sub	fp, ip, #4
 1494 0ba8 14D04DE2 		sub	sp, sp, #20
 1495 0bac 1C000BE5 		str	r0, [fp, #-28]
 1496 0bb0 0130A0E1 		mov	r3, r1
 1497 0bb4 B0324BE1 		strh	r3, [fp, #-32]	@ movhi
 419:uart.c        ****    unsigned short crc=0xff;
 1499              	.LM137:
 1500 0bb8 FF30A0E3 		mov	r3, #255
 1501 0bbc B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 420:uart.c        ****    unsigned char * ptr=(unsigned char *) data;
 1503              	.LM138:
 1504 0bc0 1C301BE5 		ldr	r3, [fp, #-28]
 1505 0bc4 14300BE5 		str	r3, [fp, #-20]
 421:uart.c        ****    int i;
 422:uart.c        **** 
 423:uart.c        ****    for (i=0;i<cnt;i++)
 1507              	.LM139:
 1508 0bc8 0030A0E3 		mov	r3, #0
 1509 0bcc 10300BE5 		str	r3, [fp, #-16]
 1510 0bd0 0D0000EA 		b	.L97
 1511              	.L98:
 424:uart.c        ****      {
 425:uart.c        ****        crc=crc_update(crc,*ptr);
 1513              	.LM140:
 1514 0bd4 B6215BE1 		ldrh	r2, [fp, #-22]
 1515 0bd8 14301BE5 		ldr	r3, [fp, #-20]
 1516 0bdc 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1517 0be0 0200A0E1 		mov	r0, r2
 1518 0be4 0310A0E1 		mov	r1, r3
 1519 0be8 FEFFFFEB 		bl	crc_update
 1520 0bec 0030A0E1 		mov	r3, r0
 1521 0bf0 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 426:uart.c        ****        ptr++;
 1523              	.LM141:
 1524 0bf4 14301BE5 		ldr	r3, [fp, #-20]
 1525 0bf8 013083E2 		add	r3, r3, #1
 1526 0bfc 14300BE5 		str	r3, [fp, #-20]
 423:uart.c        ****    for (i=0;i<cnt;i++)
 1528              	.LM142:
 1529 0c00 10301BE5 		ldr	r3, [fp, #-16]
 1530 0c04 013083E2 		add	r3, r3, #1
 1531 0c08 10300BE5 		str	r3, [fp, #-16]
 1532              	.L97:
 1533 0c0c B0225BE1 		ldrh	r2, [fp, #-32]
 1534 0c10 10301BE5 		ldr	r3, [fp, #-16]
 1535 0c14 030052E1 		cmp	r2, r3
 1536 0c18 EDFFFFCA 		bgt	.L98
 427:uart.c        ****      }
 428:uart.c        ****    return crc;
 1538              	.LM143:
 1539 0c1c B6315BE1 		ldrh	r3, [fp, #-22]
 429:uart.c        ****  }
 1541              	.LM144:
 1542 0c20 0300A0E1 		mov	r0, r3
 1543 0c24 0CD04BE2 		sub	sp, fp, #12
 1544 0c28 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1545 0c2c 1EFF2FE1 		bx	lr
 1552              	.Lscope15:
 1553              		.bss
 1554 0012 0000     		.align	2
 1555              	content.2566:
 1556 0014 00000000 		.space	4
 1558              		.align	2
 1559              	write_pointer.2565:
 1560 0018 00000000 		.space	4
 1562              		.align	2
 1563              	read_pointer.2564:
 1564 001c 00000000 		.space	4
 1566              	buffer.2563:
 1567 0020 00000000 		.space	384
 1567      00000000 
 1567      00000000 
 1567      00000000 
 1567      00000000 
 1569              		.text
 1570              		.align	2
 1575              		.global	ringbuffer
 1577              	ringbuffer:
 430:uart.c        **** 
 431:uart.c        **** // no longer a ringbuffer! - now it's a FIFO
 432:uart.c        **** int ringbuffer(unsigned char rw, unsigned char *data, unsigned int count)	//returns 1 when write/re
 433:uart.c        **** {
 1579              	.LM145:
 1580              		@ Function supports interworking.
 1581              		@ args = 0, pretend = 0, frame = 24
 1582              		@ frame_needed = 1, uses_anonymous_args = 0
 1583 0c30 0DC0A0E1 		mov	ip, sp
 1584 0c34 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1585 0c38 04B04CE2 		sub	fp, ip, #4
 1586 0c3c 18D04DE2 		sub	sp, sp, #24
 1587 0c40 0030A0E1 		mov	r3, r0
 1588 0c44 1C100BE5 		str	r1, [fp, #-28]
 1589 0c48 20200BE5 		str	r2, [fp, #-32]
 1590 0c4c 18304BE5 		strb	r3, [fp, #-24]
 434:uart.c        ****     static volatile unsigned char buffer[RINGBUFFERSIZE];
 435:uart.c        **** //	static volatile unsigned int pfirst=0, plast=0;	//Pointers to first and last to read byte
 436:uart.c        **** 	static volatile unsigned int read_pointer, write_pointer;
 437:uart.c        **** 	static volatile unsigned int content=0;
 438:uart.c        **** 	unsigned int p=0;
 1592              	.LM146:
 1593 0c50 0030A0E3 		mov	r3, #0
 1594 0c54 14300BE5 		str	r3, [fp, #-20]
 439:uart.c        ****     unsigned int p2=0;
 1596              	.LM147:
 1597 0c58 0030A0E3 		mov	r3, #0
 1598 0c5c 10300BE5 		str	r3, [fp, #-16]
 440:uart.c        **** 
 441:uart.c        **** 	if(rw==RBWRITE)
 1600              	.LM148:
 1601 0c60 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1602 0c64 010053E3 		cmp	r3, #1
 1603 0c68 2100001A 		bne	.L102
 442:uart.c        **** 	{
 443:uart.c        **** 		if(count<RINGBUFFERSIZE-content)	//enough space in buffer?
 1605              	.LM149:
 1606 0c6c 98319FE5 		ldr	r3, .L124
 1607 0c70 003093E5 		ldr	r3, [r3, #0]
 1608 0c74 062D63E2 		rsb	r2, r3, #384
 1609 0c78 20301BE5 		ldr	r3, [fp, #-32]
 1610 0c7c 030052E1 		cmp	r2, r3
 1611 0c80 5A00009A 		bls	.L110
 444:uart.c        **** 		{
 445:uart.c        **** 			while(p<count)
 1613              	.LM150:
 1614 0c84 0D0000EA 		b	.L106
 1615              	.L107:
 446:uart.c        **** 			{
 447:uart.c        **** 				buffer[write_pointer++]=data[p++];
 1617              	.LM151:
 1618 0c88 80319FE5 		ldr	r3, .L124+4
 1619 0c8c 001093E5 		ldr	r1, [r3, #0]
 1620 0c90 14201BE5 		ldr	r2, [fp, #-20]
 1621 0c94 1C301BE5 		ldr	r3, [fp, #-28]
 1622 0c98 033082E0 		add	r3, r2, r3
 1623 0c9c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1624 0ca0 6C219FE5 		ldr	r2, .L124+8
 1625 0ca4 0130C2E7 		strb	r3, [r2, r1]
 1626 0ca8 012081E2 		add	r2, r1, #1
 1627 0cac 5C319FE5 		ldr	r3, .L124+4
 1628 0cb0 002083E5 		str	r2, [r3, #0]
 1629 0cb4 14301BE5 		ldr	r3, [fp, #-20]
 1630 0cb8 013083E2 		add	r3, r3, #1
 1631 0cbc 14300BE5 		str	r3, [fp, #-20]
 1632              	.L106:
 445:uart.c        **** 			while(p<count)
 1634              	.LM152:
 1635 0cc0 14201BE5 		ldr	r2, [fp, #-20]
 1636 0cc4 20301BE5 		ldr	r3, [fp, #-32]
 1637 0cc8 030052E1 		cmp	r2, r3
 1638 0ccc EDFFFF3A 		bcc	.L107
 448:uart.c        **** 			}
 449:uart.c        ****             content+=count;
 1640              	.LM153:
 1641 0cd0 34319FE5 		ldr	r3, .L124
 1642 0cd4 002093E5 		ldr	r2, [r3, #0]
 1643 0cd8 20301BE5 		ldr	r3, [fp, #-32]
 1644 0cdc 032082E0 		add	r2, r2, r3
 1645 0ce0 24319FE5 		ldr	r3, .L124
 1646 0ce4 002083E5 		str	r2, [r3, #0]
 450:uart.c        ****             return(1);
 1648              	.LM154:
 1649 0ce8 0130A0E3 		mov	r3, #1
 1650 0cec 24300BE5 		str	r3, [fp, #-36]
 1651 0cf0 400000EA 		b	.L109
 1652              	.L102:
 451:uart.c        **** 		}
 452:uart.c        **** 	}
 453:uart.c        **** 	else if(rw==RBREAD)
 1654              	.LM155:
 1655 0cf4 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1656 0cf8 000053E3 		cmp	r3, #0
 1657 0cfc 2B00001A 		bne	.L111
 454:uart.c        **** 	{
 455:uart.c        **** 		if(content>=count)
 1659              	.LM156:
 1660 0d00 04319FE5 		ldr	r3, .L124
 1661 0d04 002093E5 		ldr	r2, [r3, #0]
 1662 0d08 20301BE5 		ldr	r3, [fp, #-32]
 1663 0d0c 030052E1 		cmp	r2, r3
 1664 0d10 3600003A 		bcc	.L110
 456:uart.c        **** 		{
 457:uart.c        **** 			while(p2<count)
 1666              	.LM157:
 1667 0d14 0E0000EA 		b	.L115
 1668              	.L116:
 458:uart.c        **** 			{
 459:uart.c        **** 				data[p2++]=buffer[read_pointer++];
 1670              	.LM158:
 1671 0d18 10201BE5 		ldr	r2, [fp, #-16]
 1672 0d1c 1C301BE5 		ldr	r3, [fp, #-28]
 1673 0d20 032082E0 		add	r2, r2, r3
 1674 0d24 EC309FE5 		ldr	r3, .L124+12
 1675 0d28 001093E5 		ldr	r1, [r3, #0]
 1676 0d2c E0309FE5 		ldr	r3, .L124+8
 1677 0d30 0130D3E7 		ldrb	r3, [r3, r1]
 1678 0d34 FF3003E2 		and	r3, r3, #255
 1679 0d38 0030C2E5 		strb	r3, [r2, #0]
 1680 0d3c 10301BE5 		ldr	r3, [fp, #-16]
 1681 0d40 013083E2 		add	r3, r3, #1
 1682 0d44 10300BE5 		str	r3, [fp, #-16]
 1683 0d48 012081E2 		add	r2, r1, #1
 1684 0d4c C4309FE5 		ldr	r3, .L124+12
 1685 0d50 002083E5 		str	r2, [r3, #0]
 1686              	.L115:
 457:uart.c        **** 			while(p2<count)
 1688              	.LM159:
 1689 0d54 10201BE5 		ldr	r2, [fp, #-16]
 1690 0d58 20301BE5 		ldr	r3, [fp, #-32]
 1691 0d5c 030052E1 		cmp	r2, r3
 1692 0d60 ECFFFF3A 		bcc	.L116
 460:uart.c        **** 			}
 461:uart.c        ****             content-=count;
 1694              	.LM160:
 1695 0d64 A0309FE5 		ldr	r3, .L124
 1696 0d68 002093E5 		ldr	r2, [r3, #0]
 1697 0d6c 20301BE5 		ldr	r3, [fp, #-32]
 1698 0d70 022063E0 		rsb	r2, r3, r2
 1699 0d74 90309FE5 		ldr	r3, .L124
 1700 0d78 002083E5 		str	r2, [r3, #0]
 462:uart.c        ****             if(!content) //buffer empty
 1702              	.LM161:
 1703 0d7c 88309FE5 		ldr	r3, .L124
 1704 0d80 003093E5 		ldr	r3, [r3, #0]
 1705 0d84 000053E3 		cmp	r3, #0
 1706 0d88 0500001A 		bne	.L118
 463:uart.c        ****             {
 464:uart.c        ****             	write_pointer=0;
 1708              	.LM162:
 1709 0d8c 7C209FE5 		ldr	r2, .L124+4
 1710 0d90 0030A0E3 		mov	r3, #0
 1711 0d94 003082E5 		str	r3, [r2, #0]
 465:uart.c        ****             	read_pointer=0;
 1713              	.LM163:
 1714 0d98 78209FE5 		ldr	r2, .L124+12
 1715 0d9c 0030A0E3 		mov	r3, #0
 1716 0da0 003082E5 		str	r3, [r2, #0]
 1717              	.L118:
 466:uart.c        ****             }
 467:uart.c        **** 			return(1);
 1719              	.LM164:
 1720 0da4 0130A0E3 		mov	r3, #1
 1721 0da8 24300BE5 		str	r3, [fp, #-36]
 1722 0dac 110000EA 		b	.L109
 1723              	.L111:
 468:uart.c        **** 		}
 469:uart.c        **** 	}
 470:uart.c        ****         else if(rw==RBFREE)
 1725              	.LM165:
 1726 0db0 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1727 0db4 020053E3 		cmp	r3, #2
 1728 0db8 0C00001A 		bne	.L110
 471:uart.c        ****         {
 472:uart.c        ****           if(content) return 0;
 1730              	.LM166:
 1731 0dbc 48309FE5 		ldr	r3, .L124
 1732 0dc0 003093E5 		ldr	r3, [r3, #0]
 1733 0dc4 000053E3 		cmp	r3, #0
 1734 0dc8 0200000A 		beq	.L121
 1735 0dcc 0030A0E3 		mov	r3, #0
 1736 0dd0 24300BE5 		str	r3, [fp, #-36]
 1737 0dd4 070000EA 		b	.L109
 1738              	.L121:
 473:uart.c        ****           else return(RINGBUFFERSIZE-11);
 1740              	.LM167:
 1741 0dd8 5D3FA0E3 		mov	r3, #372
 1742 0ddc 24300BE5 		str	r3, [fp, #-36]
 1743 0de0 24301BE5 		ldr	r3, [fp, #-36]
 1744 0de4 013083E2 		add	r3, r3, #1
 1745 0de8 24300BE5 		str	r3, [fp, #-36]
 1746 0dec 010000EA 		b	.L109
 1747              	.L110:
 474:uart.c        ****         }
 475:uart.c        **** 
 476:uart.c        **** 	return(0);
 1749              	.LM168:
 1750 0df0 0030A0E3 		mov	r3, #0
 1751 0df4 24300BE5 		str	r3, [fp, #-36]
 1752              	.L109:
 1753 0df8 24301BE5 		ldr	r3, [fp, #-36]
 477:uart.c        **** }
 1755              	.LM169:
 1756 0dfc 0300A0E1 		mov	r0, r3
 1757 0e00 0CD04BE2 		sub	sp, fp, #12
 1758 0e04 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1759 0e08 1EFF2FE1 		bx	lr
 1760              	.L125:
 1761              		.align	2
 1762              	.L124:
 1763 0e0c 14000000 		.word	content.2566
 1764 0e10 18000000 		.word	write_pointer.2565
 1765 0e14 20000000 		.word	buffer.2563
 1766 0e18 1C000000 		.word	read_pointer.2564
 1776              	.Lscope16:
 1777              		.bss
 1778              		.align	2
 1779              	content.2620:
 1780 01a0 00000000 		.space	4
 1782              		.align	2
 1783              	write_pointer.2619:
 1784 01a4 00000000 		.space	4
 1786              		.align	2
 1787              	read_pointer.2618:
 1788 01a8 00000000 		.space	4
 1790              	buffer.2617:
 1791 01ac 00000000 		.space	384
 1791      00000000 
 1791      00000000 
 1791      00000000 
 1791      00000000 
 1793              		.text
 1794              		.align	2
 1799              		.global	ringbuffer1
 1801              	ringbuffer1:
 478:uart.c        **** 
 479:uart.c        **** int ringbuffer1(unsigned char rw, unsigned char *data, unsigned int count)	//returns 1 when write/r
 480:uart.c        **** {
 1803              	.LM170:
 1804              		@ Function supports interworking.
 1805              		@ args = 0, pretend = 0, frame = 24
 1806              		@ frame_needed = 1, uses_anonymous_args = 0
 1807 0e1c 0DC0A0E1 		mov	ip, sp
 1808 0e20 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1809 0e24 04B04CE2 		sub	fp, ip, #4
 1810 0e28 18D04DE2 		sub	sp, sp, #24
 1811 0e2c 0030A0E1 		mov	r3, r0
 1812 0e30 1C100BE5 		str	r1, [fp, #-28]
 1813 0e34 20200BE5 		str	r2, [fp, #-32]
 1814 0e38 18304BE5 		strb	r3, [fp, #-24]
 481:uart.c        ****     static volatile unsigned char buffer[RINGBUFFERSIZE];
 482:uart.c        **** //	static volatile unsigned int pfirst=0, plast=0;	//Pointers to first and last to read byte
 483:uart.c        **** 	static volatile unsigned int read_pointer, write_pointer;
 484:uart.c        **** 	static volatile unsigned int content=0;
 485:uart.c        **** 	unsigned int p=0;
 1816              	.LM171:
 1817 0e3c 0030A0E3 		mov	r3, #0
 1818 0e40 14300BE5 		str	r3, [fp, #-20]
 486:uart.c        ****     unsigned int p2=0;
 1820              	.LM172:
 1821 0e44 0030A0E3 		mov	r3, #0
 1822 0e48 10300BE5 		str	r3, [fp, #-16]
 487:uart.c        **** 
 488:uart.c        **** 	if(rw==RBWRITE)
 1824              	.LM173:
 1825 0e4c 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1826 0e50 010053E3 		cmp	r3, #1
 1827 0e54 2100001A 		bne	.L127
 489:uart.c        **** 	{
 490:uart.c        **** 		if(count<RINGBUFFERSIZE-content)	//enough space in buffer?
 1829              	.LM174:
 1830 0e58 98319FE5 		ldr	r3, .L149
 1831 0e5c 003093E5 		ldr	r3, [r3, #0]
 1832 0e60 062D63E2 		rsb	r2, r3, #384
 1833 0e64 20301BE5 		ldr	r3, [fp, #-32]
 1834 0e68 030052E1 		cmp	r2, r3
 1835 0e6c 5A00009A 		bls	.L135
 491:uart.c        **** 		{
 492:uart.c        **** 			while(p<count)
 1837              	.LM175:
 1838 0e70 0D0000EA 		b	.L131
 1839              	.L132:
 493:uart.c        **** 			{
 494:uart.c        **** 				buffer[write_pointer++]=data[p++];
 1841              	.LM176:
 1842 0e74 80319FE5 		ldr	r3, .L149+4
 1843 0e78 001093E5 		ldr	r1, [r3, #0]
 1844 0e7c 14201BE5 		ldr	r2, [fp, #-20]
 1845 0e80 1C301BE5 		ldr	r3, [fp, #-28]
 1846 0e84 033082E0 		add	r3, r2, r3
 1847 0e88 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1848 0e8c 6C219FE5 		ldr	r2, .L149+8
 1849 0e90 0130C2E7 		strb	r3, [r2, r1]
 1850 0e94 012081E2 		add	r2, r1, #1
 1851 0e98 5C319FE5 		ldr	r3, .L149+4
 1852 0e9c 002083E5 		str	r2, [r3, #0]
 1853 0ea0 14301BE5 		ldr	r3, [fp, #-20]
 1854 0ea4 013083E2 		add	r3, r3, #1
 1855 0ea8 14300BE5 		str	r3, [fp, #-20]
 1856              	.L131:
 492:uart.c        **** 			while(p<count)
 1858              	.LM177:
 1859 0eac 14201BE5 		ldr	r2, [fp, #-20]
 1860 0eb0 20301BE5 		ldr	r3, [fp, #-32]
 1861 0eb4 030052E1 		cmp	r2, r3
 1862 0eb8 EDFFFF3A 		bcc	.L132
 495:uart.c        **** 			}
 496:uart.c        ****             content+=count;
 1864              	.LM178:
 1865 0ebc 34319FE5 		ldr	r3, .L149
 1866 0ec0 002093E5 		ldr	r2, [r3, #0]
 1867 0ec4 20301BE5 		ldr	r3, [fp, #-32]
 1868 0ec8 032082E0 		add	r2, r2, r3
 1869 0ecc 24319FE5 		ldr	r3, .L149
 1870 0ed0 002083E5 		str	r2, [r3, #0]
 497:uart.c        ****             return(1);
 1872              	.LM179:
 1873 0ed4 0130A0E3 		mov	r3, #1
 1874 0ed8 24300BE5 		str	r3, [fp, #-36]
 1875 0edc 400000EA 		b	.L134
 1876              	.L127:
 498:uart.c        **** 		}
 499:uart.c        **** 	}
 500:uart.c        **** 	else if(rw==RBREAD)
 1878              	.LM180:
 1879 0ee0 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1880 0ee4 000053E3 		cmp	r3, #0
 1881 0ee8 2B00001A 		bne	.L136
 501:uart.c        **** 	{
 502:uart.c        **** 		if(content>=count)
 1883              	.LM181:
 1884 0eec 04319FE5 		ldr	r3, .L149
 1885 0ef0 002093E5 		ldr	r2, [r3, #0]
 1886 0ef4 20301BE5 		ldr	r3, [fp, #-32]
 1887 0ef8 030052E1 		cmp	r2, r3
 1888 0efc 3600003A 		bcc	.L135
 503:uart.c        **** 		{
 504:uart.c        **** 			while(p2<count)
 1890              	.LM182:
 1891 0f00 0E0000EA 		b	.L140
 1892              	.L141:
 505:uart.c        **** 			{
 506:uart.c        **** 				data[p2++]=buffer[read_pointer++];
 1894              	.LM183:
 1895 0f04 10201BE5 		ldr	r2, [fp, #-16]
 1896 0f08 1C301BE5 		ldr	r3, [fp, #-28]
 1897 0f0c 032082E0 		add	r2, r2, r3
 1898 0f10 EC309FE5 		ldr	r3, .L149+12
 1899 0f14 001093E5 		ldr	r1, [r3, #0]
 1900 0f18 E0309FE5 		ldr	r3, .L149+8
 1901 0f1c 0130D3E7 		ldrb	r3, [r3, r1]
 1902 0f20 FF3003E2 		and	r3, r3, #255
 1903 0f24 0030C2E5 		strb	r3, [r2, #0]
 1904 0f28 10301BE5 		ldr	r3, [fp, #-16]
 1905 0f2c 013083E2 		add	r3, r3, #1
 1906 0f30 10300BE5 		str	r3, [fp, #-16]
 1907 0f34 012081E2 		add	r2, r1, #1
 1908 0f38 C4309FE5 		ldr	r3, .L149+12
 1909 0f3c 002083E5 		str	r2, [r3, #0]
 1910              	.L140:
 504:uart.c        **** 			while(p2<count)
 1912              	.LM184:
 1913 0f40 10201BE5 		ldr	r2, [fp, #-16]
 1914 0f44 20301BE5 		ldr	r3, [fp, #-32]
 1915 0f48 030052E1 		cmp	r2, r3
 1916 0f4c ECFFFF3A 		bcc	.L141
 507:uart.c        **** 			}
 508:uart.c        ****             content-=count;
 1918              	.LM185:
 1919 0f50 A0309FE5 		ldr	r3, .L149
 1920 0f54 002093E5 		ldr	r2, [r3, #0]
 1921 0f58 20301BE5 		ldr	r3, [fp, #-32]
 1922 0f5c 022063E0 		rsb	r2, r3, r2
 1923 0f60 90309FE5 		ldr	r3, .L149
 1924 0f64 002083E5 		str	r2, [r3, #0]
 509:uart.c        ****             if(!content) //buffer empty
 1926              	.LM186:
 1927 0f68 88309FE5 		ldr	r3, .L149
 1928 0f6c 003093E5 		ldr	r3, [r3, #0]
 1929 0f70 000053E3 		cmp	r3, #0
 1930 0f74 0500001A 		bne	.L143
 510:uart.c        ****             {
 511:uart.c        ****             	write_pointer=0;
 1932              	.LM187:
 1933 0f78 7C209FE5 		ldr	r2, .L149+4
 1934 0f7c 0030A0E3 		mov	r3, #0
 1935 0f80 003082E5 		str	r3, [r2, #0]
 512:uart.c        ****             	read_pointer=0;
 1937              	.LM188:
 1938 0f84 78209FE5 		ldr	r2, .L149+12
 1939 0f88 0030A0E3 		mov	r3, #0
 1940 0f8c 003082E5 		str	r3, [r2, #0]
 1941              	.L143:
 513:uart.c        ****             }
 514:uart.c        **** 			return(1);
 1943              	.LM189:
 1944 0f90 0130A0E3 		mov	r3, #1
 1945 0f94 24300BE5 		str	r3, [fp, #-36]
 1946 0f98 110000EA 		b	.L134
 1947              	.L136:
 515:uart.c        **** 		}
 516:uart.c        **** 	}
 517:uart.c        ****         else if(rw==RBFREE)
 1949              	.LM190:
 1950 0f9c 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1951 0fa0 020053E3 		cmp	r3, #2
 1952 0fa4 0C00001A 		bne	.L135
 518:uart.c        ****         {
 519:uart.c        ****           if(content) return 0;
 1954              	.LM191:
 1955 0fa8 48309FE5 		ldr	r3, .L149
 1956 0fac 003093E5 		ldr	r3, [r3, #0]
 1957 0fb0 000053E3 		cmp	r3, #0
 1958 0fb4 0200000A 		beq	.L146
 1959 0fb8 0030A0E3 		mov	r3, #0
 1960 0fbc 24300BE5 		str	r3, [fp, #-36]
 1961 0fc0 070000EA 		b	.L134
 1962              	.L146:
 520:uart.c        ****           else return(RINGBUFFERSIZE-11);
 1964              	.LM192:
 1965 0fc4 5D3FA0E3 		mov	r3, #372
 1966 0fc8 24300BE5 		str	r3, [fp, #-36]
 1967 0fcc 24301BE5 		ldr	r3, [fp, #-36]
 1968 0fd0 013083E2 		add	r3, r3, #1
 1969 0fd4 24300BE5 		str	r3, [fp, #-36]
 1970 0fd8 010000EA 		b	.L134
 1971              	.L135:
 521:uart.c        ****         }
 522:uart.c        **** 
 523:uart.c        **** 	return(0);
 1973              	.LM193:
 1974 0fdc 0030A0E3 		mov	r3, #0
 1975 0fe0 24300BE5 		str	r3, [fp, #-36]
 1976              	.L134:
 1977 0fe4 24301BE5 		ldr	r3, [fp, #-36]
 524:uart.c        **** }
 1979              	.LM194:
 1980 0fe8 0300A0E1 		mov	r0, r3
 1981 0fec 0CD04BE2 		sub	sp, fp, #12
 1982 0ff0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1983 0ff4 1EFF2FE1 		bx	lr
 1984              	.L150:
 1985              		.align	2
 1986              	.L149:
 1987 0ff8 A0010000 		.word	content.2620
 1988 0ffc A4010000 		.word	write_pointer.2619
 1989 1000 AC010000 		.word	buffer.2617
 1990 1004 A8010000 		.word	read_pointer.2618
 2000              	.Lscope17:
 2001              		.comm	GPS_timeout,4,4
 2002              		.comm	SYSTEM_initialized,1,1
 2003              		.comm	send_buffer,16,1
 2004              		.comm	SSP_trans_cnt,4,4
 2005              		.comm	packets,1,1
 2006              		.comm	DataOutputsPerSecond,1,1
 2007              		.comm	uart_cnt,4,4
 2008              		.comm	current_chksum,2,2
 2009              		.comm	tx_buff,4,4
 2010              		.comm	UART_rxptr,4,4
 2011              		.comm	UART1_rxptr,4,4
 2012              		.comm	my_buffer,256,1
 2041              	.Letext0:
 2042              		.ident	"GCC: (GNU) 4.1.1"
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
     /tmp/ccwYsrVq.s:141    .bss:00000000 data_requested
     /tmp/ccwYsrVq.s:142    .bss:00000000 $d
     /tmp/ccwYsrVq.s:146    .bss:00000001 chksum_to_check
     /tmp/ccwYsrVq.s:152    .data:00000000 chksum_trigger
     /tmp/ccwYsrVq.s:158    .bss:00000002 transmission_running
     /tmp/ccwYsrVq.s:163    .bss:00000003 transmission1_running
     /tmp/ccwYsrVq.s:168    .bss:00000004 trigger_transmission
     /tmp/ccwYsrVq.s:173    .bss:00000005 baudrate1_change
     /tmp/ccwYsrVq.s:178    .bss:00000006 UART_syncstate
     /tmp/ccwYsrVq.s:183    .bss:00000007 UART1_syncstate
     /tmp/ccwYsrVq.s:189    .bss:00000008 UART_rxcount
     /tmp/ccwYsrVq.s:195    .bss:0000000c UART1_rxcount
     /tmp/ccwYsrVq.s:200    .bss:00000010 UART_CalibDoneFlag
     /tmp/ccwYsrVq.s:202    .bss:00000011 rb_busy
     /tmp/ccwYsrVq.s:208    .data:00000001 startstring
     /tmp/ccwYsrVq.s:215    .data:00000004 stopstring
     /tmp/ccwYsrVq.s:220    .text:00000000 $a
     /tmp/ccwYsrVq.s:224    .text:00000000 uart1ISR
     /tmp/ccwYsrVq.s:1801   .text:00000e1c ringbuffer1
     /tmp/ccwYsrVq.s:884    .text:00000670 UART1WriteChar
     /tmp/ccwYsrVq.s:308    .text:000000cc $d
     /tmp/ccwYsrVq.s:316    .text:000000d0 $a
     /tmp/ccwYsrVq.s:320    .text:000000d0 uart0ISR
     /tmp/ccwYsrVq.s:1577   .text:00000c30 ringbuffer
     /tmp/ccwYsrVq.s:844    .text:00000620 UARTWriteChar
     /tmp/ccwYsrVq.s:434    .text:000001f8 $d
     /tmp/ccwYsrVq.s:444    .text:00000214 $a
     /tmp/ccwYsrVq.s:668    .text:00000488 $d
                            *COM*:00000100 my_buffer
     /tmp/ccwYsrVq.s:693    .text:000004c8 $a
     /tmp/ccwYsrVq.s:698    .text:000004c8 UARTInitialize
     /tmp/ccwYsrVq.s:771    .text:00000574 UART1Initialize
     /tmp/ccwYsrVq.s:923    .text:000006c0 UARTReadChar
     /tmp/ccwYsrVq.s:960    .text:00000708 UART1ReadChar
     /tmp/ccwYsrVq.s:998    .text:00000750 __putchar
     /tmp/ccwYsrVq.s:1038   .text:00000794 UART_send
     /tmp/ccwYsrVq.s:1123   .text:00000850 UART1_send
     /tmp/ccwYsrVq.s:1189   .text:000008e4 UART_send_ringbuffer
     /tmp/ccwYsrVq.s:1234   .text:00000948 $d
     /tmp/ccwYsrVq.s:1240   .text:0000094c $a
     /tmp/ccwYsrVq.s:1244   .text:0000094c UART1_send_ringbuffer
     /tmp/ccwYsrVq.s:1289   .text:000009b0 $d
     /tmp/ccwYsrVq.s:1295   .text:000009b4 $a
     /tmp/ccwYsrVq.s:1302   .text:000009b4 UART_SendPacket
     /tmp/ccwYsrVq.s:1485   .text:00000b9c crc16
     /tmp/ccwYsrVq.s:1389   .text:00000aa4 $d
     /tmp/ccwYsrVq.s:1397   .text:00000aac $a
     /tmp/ccwYsrVq.s:1403   .text:00000aac crc_update
     /tmp/ccwYsrVq.s:1555   .bss:00000014 content.2566
     /tmp/ccwYsrVq.s:1559   .bss:00000018 write_pointer.2565
     /tmp/ccwYsrVq.s:1563   .bss:0000001c read_pointer.2564
     /tmp/ccwYsrVq.s:1566   .bss:00000020 buffer.2563
     /tmp/ccwYsrVq.s:1763   .text:00000e0c $d
     /tmp/ccwYsrVq.s:1779   .bss:000001a0 content.2620
     /tmp/ccwYsrVq.s:1783   .bss:000001a4 write_pointer.2619
     /tmp/ccwYsrVq.s:1787   .bss:000001a8 read_pointer.2618
     /tmp/ccwYsrVq.s:1790   .bss:000001ac buffer.2617
     /tmp/ccwYsrVq.s:1794   .text:00000e1c $a
     /tmp/ccwYsrVq.s:1987   .text:00000ff8 $d
                            *COM*:00000004 GPS_timeout
                            *COM*:00000001 SYSTEM_initialized
                            *COM*:00000010 send_buffer
                            *COM*:00000004 SSP_trans_cnt
                            *COM*:00000001 packets
                            *COM*:00000001 DataOutputsPerSecond
                            *COM*:00000004 uart_cnt
                            *COM*:00000002 current_chksum
                            *COM*:00000004 tx_buff
                            *COM*:00000004 UART_rxptr
                            *COM*:00000004 UART1_rxptr

UNDEFINED SYMBOLS
uBloxReceiveHandler
__nesf2
my_receive
getPackageLength
memcpy
allDataBuffer
pack_id
receivedViconData
my_state
vicon_count
receiveDebugData
vicon_tp
receiveParamDebug
receive_valid_data_flag
my_this
my_setpoint
receiveCmdData
__udivsi3
peripheralClockFrequency
