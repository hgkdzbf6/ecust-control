   1              		.file	"uart.c"
   3              		.text
   4              	.Ltext0:
 143              		.global	data_requested
 144              		.bss
 147              	data_requested:
 148 0000 00       		.space	1
 149              		.global	chksum_to_check
 152              	chksum_to_check:
 153 0001 00       		.space	1
 154              		.global	chksum_trigger
 155              		.data
 158              	chksum_trigger:
 159 0000 01       		.byte	1
 160              		.global	transmission_running
 161              		.bss
 164              	transmission_running:
 165 0002 00       		.space	1
 166              		.global	transmission1_running
 169              	transmission1_running:
 170 0003 00       		.space	1
 171              		.global	trigger_transmission
 174              	trigger_transmission:
 175 0004 00       		.space	1
 176              		.global	baudrate1_change
 179              	baudrate1_change:
 180 0005 00       		.space	1
 181              		.global	UART_syncstate
 184              	UART_syncstate:
 185 0006 00       		.space	1
 186              		.global	UART1_syncstate
 189              	UART1_syncstate:
 190 0007 00       		.space	1
 191              		.global	UART_rxcount
 192              		.align	2
 195              	UART_rxcount:
 196 0008 00000000 		.space	4
 197              		.global	UART1_rxcount
 198              		.align	2
 201              	UART1_rxcount:
 202 000c 00000000 		.space	4
 203              		.global	UART_CalibDoneFlag
 206              	UART_CalibDoneFlag:
 207 0010 00       		.space	1
 208              	rb_busy:
 209 0011 00       		.space	1
 210              		.global	startstring
 211              		.data
 214              	startstring:
 215 0001 3E       		.byte	62
 216 0002 2A       		.byte	42
 217 0003 3E       		.byte	62
 218              		.global	stopstring
 221              	stopstring:
 222 0004 3C       		.byte	60
 223 0005 23       		.byte	35
 224 0006 3C       		.byte	60
 225              		.text
 226              		.align	2
 228              		.global	uart1ISR
 230              	uart1ISR:
   1:uart.c        **** /*
   2:uart.c        **** 
   3:uart.c        **** Copyright (c) 2011, Ascending Technologies GmbH
   4:uart.c        **** All rights reserved.
   5:uart.c        **** 
   6:uart.c        **** Redistribution and use in source and binary forms, with or without
   7:uart.c        **** modification, are permitted provided that the following conditions are met:
   8:uart.c        **** 
   9:uart.c        ****  * Redistributions of source code must retain the above copyright notice,
  10:uart.c        ****    this list of conditions and the following disclaimer.
  11:uart.c        ****  * Redistributions in binary form must reproduce the above copyright
  12:uart.c        ****    notice, this list of conditions and the following disclaimer in the
  13:uart.c        ****    documentation and/or other materials provided with the distribution.
  14:uart.c        **** 
  15:uart.c        **** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
  16:uart.c        **** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17:uart.c        **** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  18:uart.c        **** DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
  19:uart.c        **** DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  20:uart.c        **** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  21:uart.c        **** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  22:uart.c        **** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  23:uart.c        **** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  24:uart.c        **** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  25:uart.c        **** DAMAGE.
  26:uart.c        **** 
  27:uart.c        ****  */
  28:uart.c        **** 
  29:uart.c        **** #include "LPC214x.h"
  30:uart.c        **** #include "system.h"
  31:uart.c        **** #include "main.h"
  32:uart.c        **** #include "buzzer.h"
  33:uart.c        **** #include "uart.h"
  34:uart.c        **** #include "irq.h"
  35:uart.c        **** #include "hardware.h"
  36:uart.c        **** #include "gpsmath.h"
  37:uart.c        **** #include "ssp.h"
  38:uart.c        **** #include "sdk.h"
  39:uart.c        **** #include "ublox.h"
  40:uart.c        **** #include "pid.h"
  41:uart.c        **** #include "position_controller.h"
  42:uart.c        **** 
  43:uart.c        **** unsigned char packets;
  44:uart.c        **** unsigned char DataOutputsPerSecond;
  45:uart.c        **** unsigned int uart_cnt;
  46:uart.c        **** 
  47:uart.c        **** unsigned char data_requested=0;
  48:uart.c        **** extern int ZeroDepth;
  49:uart.c        **** 
  50:uart.c        **** unsigned short current_chksum;
  51:uart.c        **** unsigned char chksum_to_check=0;
  52:uart.c        **** unsigned char chksum_trigger=1;
  53:uart.c        **** 
  54:uart.c        **** unsigned char transmission_running=0;
  55:uart.c        **** unsigned char transmission1_running=0;
  56:uart.c        **** unsigned char trigger_transmission=0;
  57:uart.c        **** 
  58:uart.c        **** volatile unsigned char baudrate1_change=0;
  59:uart.c        **** 
  60:uart.c        **** unsigned char send_buffer[16];
  61:uart.c        **** unsigned char *tx_buff;
  62:uart.c        **** unsigned char UART_syncstate=0;
  63:uart.c        **** unsigned char UART1_syncstate=0;
  64:uart.c        **** unsigned int UART_rxcount=0;
  65:uart.c        **** unsigned char *UART_rxptr;
  66:uart.c        **** unsigned int UART1_rxcount=0;
  67:uart.c        **** unsigned char *UART1_rxptr;
  68:uart.c        **** 
  69:uart.c        **** unsigned char UART_CalibDoneFlag = 0;
  70:uart.c        **** 
  71:uart.c        **** static volatile unsigned char rb_busy=0;
  72:uart.c        **** 
  73:uart.c        **** unsigned char startstring[]={'>','*','>'};
  74:uart.c        **** unsigned char stopstring[]={'<','#','<'};
  75:uart.c        **** 
  76:uart.c        **** 
  77:uart.c        **** unsigned char my_buffer[256];
  78:uart.c        **** extern unsigned char allDataBuffer[256];
  79:uart.c        **** extern MyViconData receivedViconData;
  80:uart.c        **** extern ParamDebug sendParamDebug;
  81:uart.c        **** extern ParamDebug receiveParamDebug;
  82:uart.c        **** extern DebugData sendDebugData;
  83:uart.c        **** extern DebugData receiveDebugData;
  84:uart.c        **** extern PositionWayPointData sendPositionWayPointData;
  85:uart.c        **** extern PositionWayPointData receivePositionWayPointData;
  86:uart.c        **** extern LandSignal sendLandSignal;
  87:uart.c        **** extern LandSignal receiveLandSignal;
  88:uart.c        **** extern int vicon_count;
  89:uart.c        **** extern int receive_valid_data_flag;
  90:uart.c        **** extern struct this_s my_this ;
  91:uart.c        **** extern state_t my_state;
  92:uart.c        **** extern int output_thrust;
  93:uart.c        **** extern CmdData receiveCmdData;
  94:uart.c        **** extern int pack_id;
  95:uart.c        **** extern int vicon_tp;
  96:uart.c        **** 
  97:uart.c        **** void uart1ISR(void) __irq
  98:uart.c        **** {
 232              	.LM0:
 233              		@ Function supports interworking.
 234              		@ args = 0, pretend = 0, frame = 12
 235              		@ frame_needed = 1, uses_anonymous_args = 0
 236 0000 0DC0A0E1 		mov	ip, sp
 237 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 238 0008 04B04CE2 		sub	fp, ip, #4
 239 000c 0CD04DE2 		sub	sp, sp, #12
  99:uart.c        ****   unsigned char t;
 100:uart.c        ****   IENABLE;
 101:uart.c        ****   unsigned iir = U1IIR;
 241              	.LM1:
 242 0010 8E32A0E3 		mov	r3, #-536870904
 243 0014 013883E2 		add	r3, r3, #65536
 244 0018 003093E5 		ldr	r3, [r3, #0]
 245 001c 10300BE5 		str	r3, [fp, #-16]
 102:uart.c        ****   // Handle UART interrupt
 103:uart.c        ****   switch ((iir >> 1) & 0x7)
 247              	.LM2:
 248 0020 10301BE5 		ldr	r3, [fp, #-16]
 249 0024 A330A0E1 		mov	r3, r3, lsr #1
 250 0028 073003E2 		and	r3, r3, #7
 251 002c 18300BE5 		str	r3, [fp, #-24]
 252 0030 18301BE5 		ldr	r3, [fp, #-24]
 253 0034 010053E3 		cmp	r3, #1
 254 0038 0300000A 		beq	.L3
 255 003c 18301BE5 		ldr	r3, [fp, #-24]
 256 0040 020053E3 		cmp	r3, #2
 257 0044 1300000A 		beq	.L4
 258 0048 180000EA 		b	.L2
 259              	.L3:
 104:uart.c        ****     {
 105:uart.c        ****       case 1:
 106:uart.c        **** 		  // THRE interrupt
 107:uart.c        **** 		 if (ringbuffer1(RBREAD, &t, 1))
 261              	.LM3:
 262 004c 11304BE2 		sub	r3, fp, #17
 263 0050 0000A0E3 		mov	r0, #0
 264 0054 0310A0E1 		mov	r1, r3
 265 0058 0120A0E3 		mov	r2, #1
 266 005c FEFFFFEB 		bl	ringbuffer1
 267 0060 0030A0E1 		mov	r3, r0
 268 0064 000053E3 		cmp	r3, #0
 269 0068 0600000A 		beq	.L5
 108:uart.c        **** 		 {
 109:uart.c        **** 		   transmission1_running=1;
 271              	.LM4:
 272 006c 58209FE5 		ldr	r2, .L9
 273 0070 0130A0E3 		mov	r3, #1
 274 0074 0030C2E5 		strb	r3, [r2, #0]
 110:uart.c        **** 		   UART1WriteChar(t);
 276              	.LM5:
 277 0078 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 278 007c 0300A0E1 		mov	r0, r3
 279 0080 FEFFFFEB 		bl	UART1WriteChar
 280 0084 090000EA 		b	.L2
 281              	.L5:
 111:uart.c        **** 		 }
 112:uart.c        **** 		 else
 113:uart.c        **** 		 {
 114:uart.c        **** 		   transmission1_running=0;
 283              	.LM6:
 284 0088 3C309FE5 		ldr	r3, .L9
 285 008c 0020A0E3 		mov	r2, #0
 286 0090 0020C3E5 		strb	r2, [r3, #0]
 115:uart.c        **** 		 }
 116:uart.c        ****         break;
 288              	.LM7:
 289 0094 050000EA 		b	.L2
 290              	.L4:
 117:uart.c        ****       case 2:
 118:uart.c        ****     	// RX interrupt
 119:uart.c        **** 	    uBloxReceiveHandler(U1RBR);
 292              	.LM8:
 293 0098 0E32A0E3 		mov	r3, #-536870912
 294 009c 013883E2 		add	r3, r3, #65536
 295 00a0 003093E5 		ldr	r3, [r3, #0]
 296 00a4 FF3003E2 		and	r3, r3, #255
 297 00a8 0300A0E1 		mov	r0, r3
 298 00ac FEFFFFEB 		bl	uBloxReceiveHandler
 299              	.L2:
 120:uart.c        **** 	    break;
 121:uart.c        ****       case 3:
 122:uart.c        ****         // RLS interrupt
 123:uart.c        ****         break;
 124:uart.c        ****       case 6:
 125:uart.c        ****         // CTI interrupt
 126:uart.c        ****         break;
 127:uart.c        ****    }
 128:uart.c        ****   IDISABLE;
 129:uart.c        ****   VICVectAddr = 0;		/* Acknowledge Interrupt */
 301              	.LM9:
 302 00b0 0030A0E3 		mov	r3, #0
 303 00b4 FD3E43E2 		sub	r3, r3, #4048
 304 00b8 0020A0E3 		mov	r2, #0
 305 00bc 002083E5 		str	r2, [r3, #0]
 130:uart.c        **** }
 307              	.LM10:
 308 00c0 0CD04BE2 		sub	sp, fp, #12
 309 00c4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 310 00c8 1EFF2FE1 		bx	lr
 311              	.L10:
 312              		.align	2
 313              	.L9:
 314 00cc 00000000 		.word	transmission1_running
 320              	.Lscope0:
 321              		.global	__nesf2
 322              		.align	2
 324              		.global	uart0ISR
 326              	uart0ISR:
 131:uart.c        **** 
 132:uart.c        **** 
 133:uart.c        **** 
 134:uart.c        **** void uart0ISR(void) __irq
 135:uart.c        **** {
 328              	.LM11:
 329              		@ Function supports interworking.
 330              		@ args = 0, pretend = 0, frame = 12
 331              		@ frame_needed = 1, uses_anonymous_args = 0
 332 00d0 0DC0A0E1 		mov	ip, sp
 333 00d4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 334 00d8 04B04CE2 		sub	fp, ip, #4
 335 00dc 10D04DE2 		sub	sp, sp, #16
 136:uart.c        ****   unsigned char t;
 137:uart.c        ****   unsigned char receive_result;
 138:uart.c        ****   unsigned char UART_rxdata;
 139:uart.c        **** 
 140:uart.c        ****   // Read IIR to clear interrupt and find out the cause
 141:uart.c        ****   IENABLE;
 142:uart.c        ****   unsigned iir = U0IIR;
 337              	.LM12:
 338 00e0 0339A0E3 		mov	r3, #49152
 339 00e4 8E3283E2 		add	r3, r3, #-536870904
 340 00e8 003093E5 		ldr	r3, [r3, #0]
 341 00ec 10300BE5 		str	r3, [fp, #-16]
 143:uart.c        ****   // Handle UART interrupt
 144:uart.c        ****   switch ((iir >> 1) & 0x7)
 343              	.LM13:
 344 00f0 10301BE5 		ldr	r3, [fp, #-16]
 345 00f4 A330A0E1 		mov	r3, r3, lsr #1
 346 00f8 073003E2 		and	r3, r3, #7
 347 00fc 18300BE5 		str	r3, [fp, #-24]
 348 0100 18301BE5 		ldr	r3, [fp, #-24]
 349 0104 010053E3 		cmp	r3, #1
 350 0108 0300000A 		beq	.L13
 351 010c 18301BE5 		ldr	r3, [fp, #-24]
 352 0110 020053E3 		cmp	r3, #2
 353 0114 2000000A 		beq	.L14
 354 0118 0E0100EA 		b	.L12
 355              	.L13:
 145:uart.c        ****     {
 146:uart.c        ****       case 1:
 147:uart.c        ****         // THRE interrupt
 148:uart.c        **** 		if(!(IOPIN0&(1<<CTS_RADIO)))
 357              	.LM14:
 358 011c 0E32A0E3 		mov	r3, #-536870912
 359 0120 0A3983E2 		add	r3, r3, #163840
 360 0124 003093E5 		ldr	r3, [r3, #0]
 361 0128 013503E2 		and	r3, r3, #4194304
 362 012c 000053E3 		cmp	r3, #0
 363 0130 1500001A 		bne	.L15
 149:uart.c        **** 		{
 150:uart.c        **** 			trigger_transmission=0;
 365              	.LM15:
 366 0134 38249FE5 		ldr	r2, .L36
 367 0138 0030A0E3 		mov	r3, #0
 368 013c 0030C2E5 		strb	r3, [r2, #0]
 151:uart.c        **** 			 if (ringbuffer(RBREAD, &t, 1))
 370              	.LM16:
 371 0140 13304BE2 		sub	r3, fp, #19
 372 0144 0000A0E3 		mov	r0, #0
 373 0148 0310A0E1 		mov	r1, r3
 374 014c 0120A0E3 		mov	r2, #1
 375 0150 FEFFFFEB 		bl	ringbuffer
 376 0154 0030A0E1 		mov	r3, r0
 377 0158 000053E3 		cmp	r3, #0
 378 015c 0600000A 		beq	.L17
 152:uart.c        **** 		     {
 153:uart.c        **** 		       transmission_running=1;
 380              	.LM17:
 381 0160 10249FE5 		ldr	r2, .L36+4
 382 0164 0130A0E3 		mov	r3, #1
 383 0168 0030C2E5 		strb	r3, [r2, #0]
 154:uart.c        **** 		       UARTWriteChar(t);
 385              	.LM18:
 386 016c 13305BE5 		ldrb	r3, [fp, #-19]	@ zero_extendqisi2
 387 0170 0300A0E1 		mov	r0, r3
 388 0174 FEFFFFEB 		bl	UARTWriteChar
 389 0178 F60000EA 		b	.L12
 390              	.L17:
 155:uart.c        **** 		     }
 156:uart.c        **** 		     else
 157:uart.c        **** 		     {
 158:uart.c        **** 		       transmission_running=0;
 392              	.LM19:
 393 017c F4339FE5 		ldr	r3, .L36+4
 394 0180 0020A0E3 		mov	r2, #0
 395 0184 0020C3E5 		strb	r2, [r3, #0]
 396 0188 F20000EA 		b	.L12
 397              	.L15:
 159:uart.c        **** 		     }
 160:uart.c        **** 		}
 161:uart.c        **** 		else
 162:uart.c        **** 		{
 163:uart.c        **** 			trigger_transmission=1;
 399              	.LM20:
 400 018c E0339FE5 		ldr	r3, .L36
 401 0190 0120A0E3 		mov	r2, #1
 402 0194 0020C3E5 		strb	r2, [r3, #0]
 164:uart.c        **** 		}
 165:uart.c        **** 		break;
 404              	.LM21:
 405 0198 EE0000EA 		b	.L12
 406              	.L14:
 166:uart.c        **** 
 167:uart.c        ****       case 2:
 168:uart.c        ****         // RDA interrupt - put your HL_serial_0 receive state machine here!
 169:uart.c        ****         UART_rxdata = U0RBR;
 408              	.LM22:
 409 019c 0E32A0E3 		mov	r3, #-536870912
 410 01a0 033983E2 		add	r3, r3, #49152
 411 01a4 003093E5 		ldr	r3, [r3, #0]
 412 01a8 11304BE5 		strb	r3, [fp, #-17]
 170:uart.c        **** 
 171:uart.c        ****         receive_result=my_receive(UART_rxdata,my_buffer,
 414              	.LM23:
 415 01ac 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 416 01b0 0130A0E3 		mov	r3, #1
 417 01b4 00308DE5 		str	r3, [sp, #0]
 418 01b8 0200A0E1 		mov	r0, r2
 419 01bc B8139FE5 		ldr	r1, .L36+8
 420 01c0 B8239FE5 		ldr	r2, .L36+12
 421 01c4 B8339FE5 		ldr	r3, .L36+16
 422 01c8 FEFFFFEB 		bl	my_receive
 423 01cc 0030A0E1 		mov	r3, r0
 424 01d0 12304BE5 		strb	r3, [fp, #-18]
 172:uart.c        **** 				allDataBuffer,&pack_id,1);
 173:uart.c        **** 		if(receive_result==RECEIVE_STATE_SUCCESS){
 426              	.LM24:
 427 01d4 12305BE5 		ldrb	r3, [fp, #-18]	@ zero_extendqisi2
 428 01d8 020053E3 		cmp	r3, #2
 429 01dc DD00001A 		bne	.L12
 174:uart.c        **** 			switch(pack_id){
 431              	.LM25:
 432 01e0 9C339FE5 		ldr	r3, .L36+16
 433 01e4 003093E5 		ldr	r3, [r3, #0]
 434 01e8 013043E2 		sub	r3, r3, #1
 435 01ec 080053E3 		cmp	r3, #8
 436 01f0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 437 01f4 D70000EA 		b	.L12
 438              		.align	2
 439              	.L31:
 440 01f8 58050000 		.word	.L12
 441 01fc 1C020000 		.word	.L23
 442 0200 58050000 		.word	.L12
 443 0204 58050000 		.word	.L12
 444 0208 88020000 		.word	.L26
 445 020c 74030000 		.word	.L27
 446 0210 6C040000 		.word	.L28
 447 0214 A4040000 		.word	.L29
 448 0218 18050000 		.word	.L30
 449              	.L23:
 175:uart.c        **** 			case PACKAGE_DEFINE_STATUS:
 176:uart.c        **** 				break;
 177:uart.c        **** 			case PACKAGE_DEFINE_VICON:
 178:uart.c        **** 				memcpy(&receivedViconData,
 451              	.LM26:
 452 021c 60339FE5 		ldr	r3, .L36+16
 453 0220 003093E5 		ldr	r3, [r3, #0]
 454 0224 0300A0E1 		mov	r0, r3
 455 0228 FEFFFFEB 		bl	getPackageLength
 456 022c 0030A0E1 		mov	r3, r0
 457 0230 0310A0E1 		mov	r1, r3
 458 0234 4C339FE5 		ldr	r3, .L36+20
 459 0238 40239FE5 		ldr	r2, .L36+12
 460 023c 01C0A0E1 		mov	ip, r1
 461 0240 0300A0E1 		mov	r0, r3
 462 0244 0210A0E1 		mov	r1, r2
 463 0248 0C20A0E1 		mov	r2, ip
 464 024c FEFFFFEB 		bl	memcpy
 179:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 180:uart.c        **** 				my_state.position.z=receivedViconData.z;
 466              	.LM27:
 467 0250 30339FE5 		ldr	r3, .L36+20
 468 0254 0C2093E5 		ldr	r2, [r3, #12]	@ float
 469 0258 2C339FE5 		ldr	r3, .L36+24
 470 025c 082083E5 		str	r2, [r3, #8]	@ float
 181:uart.c        **** 				my_state.velocity.z=receivedViconData.vz;
 472              	.LM28:
 473 0260 20339FE5 		ldr	r3, .L36+20
 474 0264 242093E5 		ldr	r2, [r3, #36]	@ float
 475 0268 1C339FE5 		ldr	r3, .L36+24
 476 026c 142083E5 		str	r2, [r3, #20]	@ float
 182:uart.c        **** 				vicon_count++;
 478              	.LM29:
 479 0270 18339FE5 		ldr	r3, .L36+28
 480 0274 003093E5 		ldr	r3, [r3, #0]
 481 0278 012083E2 		add	r2, r3, #1
 482 027c 0C339FE5 		ldr	r3, .L36+28
 483 0280 002083E5 		str	r2, [r3, #0]
 183:uart.c        **** 				break;
 485              	.LM30:
 486 0284 B30000EA 		b	.L12
 487              	.L26:
 184:uart.c        **** 			case PACKAGE_DEFINE_SENSOR:
 185:uart.c        **** 				break;
 186:uart.c        **** 			case PACKAGE_DEFINE_FUSION:
 187:uart.c        **** 				break;
 188:uart.c        **** 			case PACKAGE_DEFINE_DEBUG:
 189:uart.c        **** 				memcpy(&receiveDebugData,
 489              	.LM31:
 490 0288 F4329FE5 		ldr	r3, .L36+16
 491 028c 003093E5 		ldr	r3, [r3, #0]
 492 0290 0300A0E1 		mov	r0, r3
 493 0294 FEFFFFEB 		bl	getPackageLength
 494 0298 0030A0E1 		mov	r3, r0
 495 029c 0310A0E1 		mov	r1, r3
 496 02a0 EC329FE5 		ldr	r3, .L36+32
 497 02a4 D4229FE5 		ldr	r2, .L36+12
 498 02a8 01C0A0E1 		mov	ip, r1
 499 02ac 0300A0E1 		mov	r0, r3
 500 02b0 0210A0E1 		mov	r1, r2
 501 02b4 0C20A0E1 		mov	r2, ip
 502 02b8 FEFFFFEB 		bl	memcpy
 190:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 191:uart.c        **** 				my_state.position.x=receiveDebugData.x;
 504              	.LM32:
 505 02bc D0329FE5 		ldr	r3, .L36+32
 506 02c0 042093E5 		ldr	r2, [r3, #4]	@ float
 507 02c4 C0329FE5 		ldr	r3, .L36+24
 508 02c8 002083E5 		str	r2, [r3, #0]	@ float
 192:uart.c        **** 				my_state.position.y=receiveDebugData.y;
 510              	.LM33:
 511 02cc C0329FE5 		ldr	r3, .L36+32
 512 02d0 082093E5 		ldr	r2, [r3, #8]	@ float
 513 02d4 B0329FE5 		ldr	r3, .L36+24
 514 02d8 042083E5 		str	r2, [r3, #4]	@ float
 193:uart.c        **** 				my_state.position.z=receiveDebugData.z;
 516              	.LM34:
 517 02dc B0329FE5 		ldr	r3, .L36+32
 518 02e0 0C2093E5 		ldr	r2, [r3, #12]	@ float
 519 02e4 A0329FE5 		ldr	r3, .L36+24
 520 02e8 082083E5 		str	r2, [r3, #8]	@ float
 194:uart.c        **** 				my_state.velocity.x=receiveDebugData.vx;
 522              	.LM35:
 523 02ec A0329FE5 		ldr	r3, .L36+32
 524 02f0 102093E5 		ldr	r2, [r3, #16]	@ float
 525 02f4 90329FE5 		ldr	r3, .L36+24
 526 02f8 0C2083E5 		str	r2, [r3, #12]	@ float
 195:uart.c        **** 				my_state.velocity.y=receiveDebugData.vy;
 528              	.LM36:
 529 02fc 90329FE5 		ldr	r3, .L36+32
 530 0300 142093E5 		ldr	r2, [r3, #20]	@ float
 531 0304 80329FE5 		ldr	r3, .L36+24
 532 0308 102083E5 		str	r2, [r3, #16]	@ float
 196:uart.c        **** 				my_state.velocity.z=receiveDebugData.vz;
 534              	.LM37:
 535 030c 80329FE5 		ldr	r3, .L36+32
 536 0310 182093E5 		ldr	r2, [r3, #24]	@ float
 537 0314 70329FE5 		ldr	r3, .L36+24
 538 0318 142083E5 		str	r2, [r3, #20]	@ float
 197:uart.c        **** 				my_state.attitude.pitch=receiveDebugData.pitch;
 540              	.LM38:
 541 031c 70329FE5 		ldr	r3, .L36+32
 542 0320 1C2093E5 		ldr	r2, [r3, #28]	@ float
 543 0324 60329FE5 		ldr	r3, .L36+24
 544 0328 202083E5 		str	r2, [r3, #32]	@ float
 198:uart.c        **** 				my_state.attitude.roll=receiveDebugData.roll;
 546              	.LM39:
 547 032c 60329FE5 		ldr	r3, .L36+32
 548 0330 202093E5 		ldr	r2, [r3, #32]	@ float
 549 0334 50329FE5 		ldr	r3, .L36+24
 550 0338 1C2083E5 		str	r2, [r3, #28]	@ float
 199:uart.c        **** 				my_state.attitude.yaw=receiveDebugData.yaw;
 552              	.LM40:
 553 033c 50329FE5 		ldr	r3, .L36+32
 554 0340 242093E5 		ldr	r2, [r3, #36]	@ float
 555 0344 40329FE5 		ldr	r3, .L36+24
 556 0348 242083E5 		str	r2, [r3, #36]	@ float
 200:uart.c        **** 				vicon_tp=receiveDebugData.timestamp;
 558              	.LM41:
 559 034c 40329FE5 		ldr	r3, .L36+32
 560 0350 002093E5 		ldr	r2, [r3, #0]
 561 0354 3C329FE5 		ldr	r3, .L36+36
 562 0358 002083E5 		str	r2, [r3, #0]
 201:uart.c        **** 				vicon_count++;
 564              	.LM42:
 565 035c 2C329FE5 		ldr	r3, .L36+28
 566 0360 003093E5 		ldr	r3, [r3, #0]
 567 0364 012083E2 		add	r2, r3, #1
 568 0368 20329FE5 		ldr	r3, .L36+28
 569 036c 002083E5 		str	r2, [r3, #0]
 202:uart.c        **** 				break;
 571              	.LM43:
 572 0370 780000EA 		b	.L12
 573              	.L27:
 203:uart.c        **** 			case PACKAGE_DEFINE_PARAM:
 204:uart.c        **** 				memcpy(&receiveParamDebug,
 575              	.LM44:
 576 0374 08329FE5 		ldr	r3, .L36+16
 577 0378 003093E5 		ldr	r3, [r3, #0]
 578 037c 0300A0E1 		mov	r0, r3
 579 0380 FEFFFFEB 		bl	getPackageLength
 580 0384 0030A0E1 		mov	r3, r0
 581 0388 0310A0E1 		mov	r1, r3
 582 038c 08329FE5 		ldr	r3, .L36+40
 583 0390 E8219FE5 		ldr	r2, .L36+12
 584 0394 01C0A0E1 		mov	ip, r1
 585 0398 0300A0E1 		mov	r0, r3
 586 039c 0210A0E1 		mov	r1, r2
 587 03a0 0C20A0E1 		mov	r2, ip
 588 03a4 FEFFFFEB 		bl	memcpy
 205:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 206:uart.c        **** 	        	if(receiveParamDebug.kp_p!=0){
 590              	.LM45:
 591 03a8 EC319FE5 		ldr	r3, .L36+40
 592 03ac 0C3093E5 		ldr	r3, [r3, #12]	@ float
 593 03b0 0300A0E1 		mov	r0, r3
 594 03b4 E4119FE5 		ldr	r1, .L36+44	@ float
 595 03b8 FEFFFFEB 		bl	__nesf2
 596 03bc 0030A0E1 		mov	r3, r0
 597 03c0 000053E3 		cmp	r3, #0
 598 03c4 0000001A 		bne	.L34
 599 03c8 160000EA 		b	.L32
 600              	.L34:
 207:uart.c        **** 	        		receive_valid_data_flag=1;
 602              	.LM46:
 603 03cc D0219FE5 		ldr	r2, .L36+48
 604 03d0 0130A0E3 		mov	r3, #1
 605 03d4 003082E5 		str	r3, [r2, #0]
 208:uart.c        **** 	        		my_this.pidZ.pid.kp=receiveParamDebug.kp_p;
 607              	.LM47:
 608 03d8 BC319FE5 		ldr	r3, .L36+40
 609 03dc 0C2093E5 		ldr	r2, [r3, #12]	@ float
 610 03e0 C0319FE5 		ldr	r3, .L36+52
 611 03e4 602083E5 		str	r2, [r3, #96]	@ float
 209:uart.c        **** 	        		my_this.pidZ.pid.ki=receiveParamDebug.ki_p;
 613              	.LM48:
 614 03e8 AC319FE5 		ldr	r3, .L36+40
 615 03ec 102093E5 		ldr	r2, [r3, #16]	@ float
 616 03f0 B0319FE5 		ldr	r3, .L36+52
 617 03f4 642083E5 		str	r2, [r3, #100]	@ float
 210:uart.c        **** 	        		my_this.pidVZ.pid.kp=receiveParamDebug.kp_v;
 619              	.LM49:
 620 03f8 9C319FE5 		ldr	r3, .L36+40
 621 03fc 042093E5 		ldr	r2, [r3, #4]	@ float
 622 0400 A0319FE5 		ldr	r3, .L36+52
 623 0404 142083E5 		str	r2, [r3, #20]	@ float
 211:uart.c        **** 	        		my_this.pidVZ.pid.ki=receiveParamDebug.ki_v;
 625              	.LM50:
 626 0408 8C319FE5 		ldr	r3, .L36+40
 627 040c 082093E5 		ldr	r2, [r3, #8]	@ float
 628 0410 90319FE5 		ldr	r3, .L36+52
 629 0414 182083E5 		str	r2, [r3, #24]	@ float
 212:uart.c        **** 	        		my_setpoint.velocity.z=receiveParamDebug.set_velocity;
 631              	.LM51:
 632 0418 7C319FE5 		ldr	r3, .L36+40
 633 041c 1C2093E5 		ldr	r2, [r3, #28]	@ float
 634 0420 84319FE5 		ldr	r3, .L36+56
 635 0424 142083E5 		str	r2, [r3, #20]	@ float
 636              	.L32:
 213:uart.c        **** 	        	}
 214:uart.c        **** 	    		my_state.position.z=receiveParamDebug.z;
 638              	.LM52:
 639 0428 6C319FE5 		ldr	r3, .L36+40
 640 042c 142093E5 		ldr	r2, [r3, #20]	@ float
 641 0430 54319FE5 		ldr	r3, .L36+24
 642 0434 082083E5 		str	r2, [r3, #8]	@ float
 215:uart.c        **** 	    		my_state.velocity.z=receiveParamDebug.vz;
 644              	.LM53:
 645 0438 5C319FE5 		ldr	r3, .L36+40
 646 043c 182093E5 		ldr	r2, [r3, #24]	@ float
 647 0440 44319FE5 		ldr	r3, .L36+24
 648 0444 142083E5 		str	r2, [r3, #20]	@ float
 216:uart.c        **** 	        	vicon_count++;
 650              	.LM54:
 651 0448 40319FE5 		ldr	r3, .L36+28
 652 044c 003093E5 		ldr	r3, [r3, #0]
 653 0450 012083E2 		add	r2, r3, #1
 654 0454 34319FE5 		ldr	r3, .L36+28
 655 0458 002083E5 		str	r2, [r3, #0]
 217:uart.c        **** 				receiveCmdData.cmd=PACKAGE_DEFINE_PARAM;
 657              	.LM55:
 658 045c 4C219FE5 		ldr	r2, .L36+60
 659 0460 0630A0E3 		mov	r3, #6
 660 0464 003082E5 		str	r3, [r2, #0]
 218:uart.c        **** 				break;
 662              	.LM56:
 663 0468 3A0000EA 		b	.L12
 664              	.L28:
 219:uart.c        **** 			case PACKAGE_DEFINE_CMD:
 220:uart.c        **** 				memcpy(&receiveCmdData,
 666              	.LM57:
 667 046c 10319FE5 		ldr	r3, .L36+16
 668 0470 003093E5 		ldr	r3, [r3, #0]
 669 0474 0300A0E1 		mov	r0, r3
 670 0478 FEFFFFEB 		bl	getPackageLength
 671 047c 0030A0E1 		mov	r3, r0
 672 0480 0310A0E1 		mov	r1, r3
 673 0484 24319FE5 		ldr	r3, .L36+60
 674 0488 F0209FE5 		ldr	r2, .L36+12
 675 048c 01C0A0E1 		mov	ip, r1
 676 0490 0300A0E1 		mov	r0, r3
 677 0494 0210A0E1 		mov	r1, r2
 678 0498 0C20A0E1 		mov	r2, ip
 679 049c FEFFFFEB 		bl	memcpy
 221:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 222:uart.c        **** 				break;
 681              	.LM58:
 682 04a0 2C0000EA 		b	.L12
 683              	.L29:
 223:uart.c        **** 			case PACKAGE_DEFINE_POSITION_WAY_POINT:
 224:uart.c        **** 				memcpy(&receivePositionWayPointData,
 685              	.LM59:
 686 04a4 D8309FE5 		ldr	r3, .L36+16
 687 04a8 003093E5 		ldr	r3, [r3, #0]
 688 04ac 0300A0E1 		mov	r0, r3
 689 04b0 FEFFFFEB 		bl	getPackageLength
 690 04b4 0030A0E1 		mov	r3, r0
 691 04b8 0310A0E1 		mov	r1, r3
 692 04bc F0309FE5 		ldr	r3, .L36+64
 693 04c0 B8209FE5 		ldr	r2, .L36+12
 694 04c4 01C0A0E1 		mov	ip, r1
 695 04c8 0300A0E1 		mov	r0, r3
 696 04cc 0210A0E1 		mov	r1, r2
 697 04d0 0C20A0E1 		mov	r2, ip
 698 04d4 FEFFFFEB 		bl	memcpy
 225:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 226:uart.c        **** 				my_setpoint.position.x=receivePositionWayPointData.x;
 700              	.LM60:
 701 04d8 D4309FE5 		ldr	r3, .L36+64
 702 04dc 002093E5 		ldr	r2, [r3, #0]	@ float
 703 04e0 C4309FE5 		ldr	r3, .L36+56
 704 04e4 002083E5 		str	r2, [r3, #0]	@ float
 227:uart.c        **** 				my_setpoint.position.y=receivePositionWayPointData.y;
 706              	.LM61:
 707 04e8 C4309FE5 		ldr	r3, .L36+64
 708 04ec 042093E5 		ldr	r2, [r3, #4]	@ float
 709 04f0 B4309FE5 		ldr	r3, .L36+56
 710 04f4 042083E5 		str	r2, [r3, #4]	@ float
 228:uart.c        **** 				my_setpoint.position.z=receivePositionWayPointData.z;
 712              	.LM62:
 713 04f8 B4309FE5 		ldr	r3, .L36+64
 714 04fc 082093E5 		ldr	r2, [r3, #8]	@ float
 715 0500 A4309FE5 		ldr	r3, .L36+56
 716 0504 082083E5 		str	r2, [r3, #8]	@ float
 229:uart.c        **** 				receiveCmdData.cmd=PACKAGE_DEFINE_POSITION_WAY_POINT;
 718              	.LM63:
 719 0508 A0209FE5 		ldr	r2, .L36+60
 720 050c 0830A0E3 		mov	r3, #8
 721 0510 003082E5 		str	r3, [r2, #0]
 230:uart.c        **** 				break;
 723              	.LM64:
 724 0514 0F0000EA 		b	.L12
 725              	.L30:
 231:uart.c        **** 			case PACKAGE_DEFINE_LAND:
 232:uart.c        **** 				memcpy(&receiveLandSignal,
 727              	.LM65:
 728 0518 64309FE5 		ldr	r3, .L36+16
 729 051c 003093E5 		ldr	r3, [r3, #0]
 730 0520 0300A0E1 		mov	r0, r3
 731 0524 FEFFFFEB 		bl	getPackageLength
 732 0528 0030A0E1 		mov	r3, r0
 733 052c 0310A0E1 		mov	r1, r3
 734 0530 80309FE5 		ldr	r3, .L36+68
 735 0534 44209FE5 		ldr	r2, .L36+12
 736 0538 01C0A0E1 		mov	ip, r1
 737 053c 0300A0E1 		mov	r0, r3
 738 0540 0210A0E1 		mov	r1, r2
 739 0544 0C20A0E1 		mov	r2, ip
 740 0548 FEFFFFEB 		bl	memcpy
 233:uart.c        **** 						&allDataBuffer,getPackageLength(pack_id));
 234:uart.c        **** 				receiveCmdData.cmd=PACKAGE_DEFINE_LAND;
 742              	.LM66:
 743 054c 5C209FE5 		ldr	r2, .L36+60
 744 0550 0930A0E3 		mov	r3, #9
 745 0554 003082E5 		str	r3, [r2, #0]
 746              	.L12:
 235:uart.c        **** 				break;
 236:uart.c        **** 			default:
 237:uart.c        **** 				break;
 238:uart.c        **** 			}
 239:uart.c        ****         }
 240:uart.c        **** 
 241:uart.c        **** //        if (UART_syncstate==0)
 242:uart.c        **** //		{
 243:uart.c        **** //			if (UART_rxdata=='>') UART_syncstate++; else UART_syncstate=0;
 244:uart.c        **** //		}
 245:uart.c        **** //		else if (UART_syncstate==1)
 246:uart.c        **** //		{
 247:uart.c        **** //			if (UART_rxdata=='*') UART_syncstate++; else UART_syncstate=0;
 248:uart.c        **** //		}
 249:uart.c        **** //		else if (UART_syncstate==2)
 250:uart.c        **** //		{
 251:uart.c        **** //			if (UART_rxdata=='>') UART_syncstate++; else UART_syncstate=0;
 252:uart.c        **** //		}
 253:uart.c        **** //		else if (UART_syncstate==3)
 254:uart.c        **** //		{
 255:uart.c        **** //			//synchronized to start string => receive your data from here
 256:uart.c        **** //           UART_syncstate=0;
 257:uart.c        **** //        }
 258:uart.c        **** //		else UART_syncstate=0;
 259:uart.c        **** 
 260:uart.c        **** 
 261:uart.c        **** 
 262:uart.c        **** 
 263:uart.c        **** 
 264:uart.c        **** 
 265:uart.c        ****         break;
 266:uart.c        ****       case 3:
 267:uart.c        ****         // RLS interrupt
 268:uart.c        ****         break;
 269:uart.c        ****       case 6:
 270:uart.c        ****         // CTI interrupt
 271:uart.c        ****         break;
 272:uart.c        ****   }
 273:uart.c        ****   IDISABLE;
 274:uart.c        ****   VICVectAddr = 0;		// Acknowledge Interrupt
 748              	.LM67:
 749 0558 0030A0E3 		mov	r3, #0
 750 055c FD3E43E2 		sub	r3, r3, #4048
 751 0560 0020A0E3 		mov	r2, #0
 752 0564 002083E5 		str	r2, [r3, #0]
 275:uart.c        ****  }
 754              	.LM68:
 755 0568 0CD04BE2 		sub	sp, fp, #12
 756 056c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 757 0570 1EFF2FE1 		bx	lr
 758              	.L37:
 759              		.align	2
 760              	.L36:
 761 0574 00000000 		.word	trigger_transmission
 762 0578 00000000 		.word	transmission_running
 763 057c 00000000 		.word	my_buffer
 764 0580 00000000 		.word	allDataBuffer
 765 0584 00000000 		.word	pack_id
 766 0588 00000000 		.word	receivedViconData
 767 058c 00000000 		.word	my_state
 768 0590 00000000 		.word	vicon_count
 769 0594 00000000 		.word	receiveDebugData
 770 0598 00000000 		.word	vicon_tp
 771 059c 00000000 		.word	receiveParamDebug
 772 05a0 00000000 		.word	0
 773 05a4 00000000 		.word	receive_valid_data_flag
 774 05a8 00000000 		.word	my_this
 775 05ac 00000000 		.word	my_setpoint
 776 05b0 00000000 		.word	receiveCmdData
 777 05b4 00000000 		.word	receivePositionWayPointData
 778 05b8 00000000 		.word	receiveLandSignal
 786              	.Lscope1:
 787              		.global	__udivsi3
 788              		.align	2
 791              		.global	UARTInitialize
 793              	UARTInitialize:
 276:uart.c        **** 
 277:uart.c        **** 
 278:uart.c        **** void UARTInitialize(unsigned int baud)
 279:uart.c        **** {
 795              	.LM69:
 796              		@ Function supports interworking.
 797              		@ args = 0, pretend = 0, frame = 8
 798              		@ frame_needed = 1, uses_anonymous_args = 0
 799 05bc 0DC0A0E1 		mov	ip, sp
 800 05c0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 801 05c4 04B04CE2 		sub	fp, ip, #4
 802 05c8 08D04DE2 		sub	sp, sp, #8
 803 05cc 14000BE5 		str	r0, [fp, #-20]
 280:uart.c        ****   unsigned int divisor = peripheralClockFrequency() / (16 * baud);
 805              	.LM70:
 806 05d0 FEFFFFEB 		bl	peripheralClockFrequency
 807 05d4 0020A0E1 		mov	r2, r0
 808 05d8 14301BE5 		ldr	r3, [fp, #-20]
 809 05dc 0332A0E1 		mov	r3, r3, asl #4
 810 05e0 0200A0E1 		mov	r0, r2
 811 05e4 0310A0E1 		mov	r1, r3
 812 05e8 FEFFFFEB 		bl	__udivsi3
 813 05ec 0030A0E1 		mov	r3, r0
 814 05f0 10300BE5 		str	r3, [fp, #-16]
 281:uart.c        **** 
 282:uart.c        ****   //UART0
 283:uart.c        ****   U0LCR = 0x83; /* 8 bit, 1 stop bit, no parity, enable DLAB */
 816              	.LM71:
 817 05f4 0339A0E3 		mov	r3, #49152
 818 05f8 CE3283E2 		add	r3, r3, #-536870900
 819 05fc 8320A0E3 		mov	r2, #131
 820 0600 002083E5 		str	r2, [r3, #0]
 284:uart.c        ****   U0DLL = divisor & 0xFF;
 822              	.LM72:
 823 0604 0E32A0E3 		mov	r3, #-536870912
 824 0608 033983E2 		add	r3, r3, #49152
 825 060c 10201BE5 		ldr	r2, [fp, #-16]
 826 0610 FF2002E2 		and	r2, r2, #255
 827 0614 002083E5 		str	r2, [r3, #0]
 285:uart.c        ****   U0DLM = (divisor >> 8) & 0xFF;
 829              	.LM73:
 830 0618 0329A0E3 		mov	r2, #49152
 831 061c 4E2282E2 		add	r2, r2, #-536870908
 832 0620 10301BE5 		ldr	r3, [fp, #-16]
 833 0624 2334A0E1 		mov	r3, r3, lsr #8
 834 0628 FF3003E2 		and	r3, r3, #255
 835 062c 003082E5 		str	r3, [r2, #0]
 286:uart.c        ****   U0LCR &= ~0x80; /* Disable DLAB */
 837              	.LM74:
 838 0630 0329A0E3 		mov	r2, #49152
 839 0634 CE2282E2 		add	r2, r2, #-536870900
 840 0638 0339A0E3 		mov	r3, #49152
 841 063c CE3283E2 		add	r3, r3, #-536870900
 842 0640 003093E5 		ldr	r3, [r3, #0]
 843 0644 8030C3E3 		bic	r3, r3, #128
 844 0648 003082E5 		str	r3, [r2, #0]
 287:uart.c        ****   U0FCR = 1;
 846              	.LM75:
 847 064c 0339A0E3 		mov	r3, #49152
 848 0650 8E3283E2 		add	r3, r3, #-536870904
 849 0654 0120A0E3 		mov	r2, #1
 850 0658 002083E5 		str	r2, [r3, #0]
 288:uart.c        **** 
 289:uart.c        **** 
 290:uart.c        **** }
 852              	.LM76:
 853 065c 0CD04BE2 		sub	sp, fp, #12
 854 0660 00689DE8 		ldmfd	sp, {fp, sp, lr}
 855 0664 1EFF2FE1 		bx	lr
 860              	.Lscope2:
 861              		.align	2
 864              		.global	UART1Initialize
 866              	UART1Initialize:
 291:uart.c        **** 
 292:uart.c        **** void UART1Initialize(unsigned int baud)
 293:uart.c        **** {
 868              	.LM77:
 869              		@ Function supports interworking.
 870              		@ args = 0, pretend = 0, frame = 8
 871              		@ frame_needed = 1, uses_anonymous_args = 0
 872 0668 0DC0A0E1 		mov	ip, sp
 873 066c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 874 0670 04B04CE2 		sub	fp, ip, #4
 875 0674 08D04DE2 		sub	sp, sp, #8
 876 0678 14000BE5 		str	r0, [fp, #-20]
 294:uart.c        ****   unsigned int divisor = peripheralClockFrequency() / (16 * baud);
 878              	.LM78:
 879 067c FEFFFFEB 		bl	peripheralClockFrequency
 880 0680 0020A0E1 		mov	r2, r0
 881 0684 14301BE5 		ldr	r3, [fp, #-20]
 882 0688 0332A0E1 		mov	r3, r3, asl #4
 883 068c 0200A0E1 		mov	r0, r2
 884 0690 0310A0E1 		mov	r1, r3
 885 0694 FEFFFFEB 		bl	__udivsi3
 886 0698 0030A0E1 		mov	r3, r0
 887 069c 10300BE5 		str	r3, [fp, #-16]
 295:uart.c        **** //UART1
 296:uart.c        ****   U1LCR = 0x83; /* 8 bit, 1 stop bit, no parity, enable DLAB */
 889              	.LM79:
 890 06a0 CE32A0E3 		mov	r3, #-536870900
 891 06a4 013883E2 		add	r3, r3, #65536
 892 06a8 8320A0E3 		mov	r2, #131
 893 06ac 002083E5 		str	r2, [r3, #0]
 297:uart.c        ****   U1DLL = divisor & 0xFF;
 895              	.LM80:
 896 06b0 0E32A0E3 		mov	r3, #-536870912
 897 06b4 013883E2 		add	r3, r3, #65536
 898 06b8 10201BE5 		ldr	r2, [fp, #-16]
 899 06bc FF2002E2 		and	r2, r2, #255
 900 06c0 002083E5 		str	r2, [r3, #0]
 298:uart.c        ****   U1DLM = (divisor >> 8) & 0xFF;
 902              	.LM81:
 903 06c4 4E22A0E3 		mov	r2, #-536870908
 904 06c8 012882E2 		add	r2, r2, #65536
 905 06cc 10301BE5 		ldr	r3, [fp, #-16]
 906 06d0 2334A0E1 		mov	r3, r3, lsr #8
 907 06d4 FF3003E2 		and	r3, r3, #255
 908 06d8 003082E5 		str	r3, [r2, #0]
 299:uart.c        ****   U1LCR &= ~0x80; /* Disable DLAB */
 910              	.LM82:
 911 06dc CE22A0E3 		mov	r2, #-536870900
 912 06e0 012882E2 		add	r2, r2, #65536
 913 06e4 CE32A0E3 		mov	r3, #-536870900
 914 06e8 013883E2 		add	r3, r3, #65536
 915 06ec 003093E5 		ldr	r3, [r3, #0]
 916 06f0 8030C3E3 		bic	r3, r3, #128
 917 06f4 003082E5 		str	r3, [r2, #0]
 300:uart.c        ****   U1FCR = 1;
 919              	.LM83:
 920 06f8 8E32A0E3 		mov	r3, #-536870904
 921 06fc 013883E2 		add	r3, r3, #65536
 922 0700 0120A0E3 		mov	r2, #1
 923 0704 002083E5 		str	r2, [r3, #0]
 301:uart.c        **** }
 925              	.LM84:
 926 0708 0CD04BE2 		sub	sp, fp, #12
 927 070c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 928 0710 1EFF2FE1 		bx	lr
 933              	.Lscope3:
 934              		.align	2
 937              		.global	UARTWriteChar
 939              	UARTWriteChar:
 302:uart.c        **** 
 303:uart.c        **** 
 304:uart.c        **** //Write to UART0
 305:uart.c        **** void UARTWriteChar(unsigned char ch)
 306:uart.c        **** {
 941              	.LM85:
 942              		@ Function supports interworking.
 943              		@ args = 0, pretend = 0, frame = 4
 944              		@ frame_needed = 1, uses_anonymous_args = 0
 945 0714 0DC0A0E1 		mov	ip, sp
 946 0718 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 947 071c 04B04CE2 		sub	fp, ip, #4
 948 0720 04D04DE2 		sub	sp, sp, #4
 949 0724 0030A0E1 		mov	r3, r0
 950 0728 10304BE5 		strb	r3, [fp, #-16]
 951              	.L43:
 307:uart.c        ****   while ((U0LSR & 0x20) == 0);
 953              	.LM86:
 954 072c 0E32A0E3 		mov	r3, #-536870912
 955 0730 033983E2 		add	r3, r3, #49152
 956 0734 143083E2 		add	r3, r3, #20
 957 0738 003093E5 		ldr	r3, [r3, #0]
 958 073c 203003E2 		and	r3, r3, #32
 959 0740 000053E3 		cmp	r3, #0
 960 0744 F8FFFF0A 		beq	.L43
 308:uart.c        ****   U0THR = ch;
 962              	.LM87:
 963 0748 0E32A0E3 		mov	r3, #-536870912
 964 074c 033983E2 		add	r3, r3, #49152
 965 0750 10205BE5 		ldrb	r2, [fp, #-16]	@ zero_extendqisi2
 966 0754 002083E5 		str	r2, [r3, #0]
 309:uart.c        **** }
 968              	.LM88:
 969 0758 0CD04BE2 		sub	sp, fp, #12
 970 075c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 971 0760 1EFF2FE1 		bx	lr
 973              	.Lscope4:
 974              		.align	2
 977              		.global	UART1WriteChar
 979              	UART1WriteChar:
 310:uart.c        **** //Write to UART1
 311:uart.c        **** void UART1WriteChar(unsigned char ch)
 312:uart.c        **** {
 981              	.LM89:
 982              		@ Function supports interworking.
 983              		@ args = 0, pretend = 0, frame = 4
 984              		@ frame_needed = 1, uses_anonymous_args = 0
 985 0764 0DC0A0E1 		mov	ip, sp
 986 0768 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 987 076c 04B04CE2 		sub	fp, ip, #4
 988 0770 04D04DE2 		sub	sp, sp, #4
 989 0774 0030A0E1 		mov	r3, r0
 990 0778 10304BE5 		strb	r3, [fp, #-16]
 991              	.L47:
 313:uart.c        ****   while ((U1LSR & 0x20) == 0);
 993              	.LM90:
 994 077c 0E32A0E3 		mov	r3, #-536870912
 995 0780 013883E2 		add	r3, r3, #65536
 996 0784 143083E2 		add	r3, r3, #20
 997 0788 003093E5 		ldr	r3, [r3, #0]
 998 078c 203003E2 		and	r3, r3, #32
 999 0790 000053E3 		cmp	r3, #0
 1000 0794 F8FFFF0A 		beq	.L47
 314:uart.c        ****   U1THR = ch;
 1002              	.LM91:
 1003 0798 0E32A0E3 		mov	r3, #-536870912
 1004 079c 013883E2 		add	r3, r3, #65536
 1005 07a0 10205BE5 		ldrb	r2, [fp, #-16]	@ zero_extendqisi2
 1006 07a4 002083E5 		str	r2, [r3, #0]
 315:uart.c        **** }
 1008              	.LM92:
 1009 07a8 0CD04BE2 		sub	sp, fp, #12
 1010 07ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1011 07b0 1EFF2FE1 		bx	lr
 1013              	.Lscope5:
 1014              		.align	2
 1016              		.global	UARTReadChar
 1018              	UARTReadChar:
 316:uart.c        **** 
 317:uart.c        **** unsigned char UARTReadChar(void)
 318:uart.c        **** {
 1020              	.LM93:
 1021              		@ Function supports interworking.
 1022              		@ args = 0, pretend = 0, frame = 0
 1023              		@ frame_needed = 1, uses_anonymous_args = 0
 1024 07b4 0DC0A0E1 		mov	ip, sp
 1025 07b8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1026 07bc 04B04CE2 		sub	fp, ip, #4
 1027              	.L51:
 319:uart.c        ****   while ((U0LSR & 0x01) == 0);
 1029              	.LM94:
 1030 07c0 0E32A0E3 		mov	r3, #-536870912
 1031 07c4 033983E2 		add	r3, r3, #49152
 1032 07c8 143083E2 		add	r3, r3, #20
 1033 07cc 003093E5 		ldr	r3, [r3, #0]
 1034 07d0 013003E2 		and	r3, r3, #1
 1035 07d4 000053E3 		cmp	r3, #0
 1036 07d8 F8FFFF0A 		beq	.L51
 320:uart.c        ****   return U0RBR;
 1038              	.LM95:
 1039 07dc 0E32A0E3 		mov	r3, #-536870912
 1040 07e0 033983E2 		add	r3, r3, #49152
 1041 07e4 003093E5 		ldr	r3, [r3, #0]
 1042 07e8 FF3003E2 		and	r3, r3, #255
 321:uart.c        **** }
 1044              	.LM96:
 1045 07ec 0300A0E1 		mov	r0, r3
 1046 07f0 0CD04BE2 		sub	sp, fp, #12
 1047 07f4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1048 07f8 1EFF2FE1 		bx	lr
 1050              	.Lscope6:
 1051              		.align	2
 1053              		.global	UART1ReadChar
 1055              	UART1ReadChar:
 322:uart.c        **** 
 323:uart.c        **** unsigned char UART1ReadChar(void)
 324:uart.c        **** {
 1057              	.LM97:
 1058              		@ Function supports interworking.
 1059              		@ args = 0, pretend = 0, frame = 0
 1060              		@ frame_needed = 1, uses_anonymous_args = 0
 1061 07fc 0DC0A0E1 		mov	ip, sp
 1062 0800 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1063 0804 04B04CE2 		sub	fp, ip, #4
 1064              	.L55:
 325:uart.c        ****   while ((U1LSR & 0x01) == 0);
 1066              	.LM98:
 1067 0808 0E32A0E3 		mov	r3, #-536870912
 1068 080c 013883E2 		add	r3, r3, #65536
 1069 0810 143083E2 		add	r3, r3, #20
 1070 0814 003093E5 		ldr	r3, [r3, #0]
 1071 0818 013003E2 		and	r3, r3, #1
 1072 081c 000053E3 		cmp	r3, #0
 1073 0820 F8FFFF0A 		beq	.L55
 326:uart.c        ****   return U1RBR;
 1075              	.LM99:
 1076 0824 0E32A0E3 		mov	r3, #-536870912
 1077 0828 013883E2 		add	r3, r3, #65536
 1078 082c 003093E5 		ldr	r3, [r3, #0]
 1079 0830 FF3003E2 		and	r3, r3, #255
 327:uart.c        **** }
 1081              	.LM100:
 1082 0834 0300A0E1 		mov	r0, r3
 1083 0838 0CD04BE2 		sub	sp, fp, #12
 1084 083c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1085 0840 1EFF2FE1 		bx	lr
 1087              	.Lscope7:
 1088              		.align	2
 1091              		.global	__putchar
 1093              	__putchar:
 328:uart.c        **** 
 329:uart.c        **** void __putchar(int ch)
 330:uart.c        **** {
 1095              	.LM101:
 1096              		@ Function supports interworking.
 1097              		@ args = 0, pretend = 0, frame = 4
 1098              		@ frame_needed = 1, uses_anonymous_args = 0
 1099 0844 0DC0A0E1 		mov	ip, sp
 1100 0848 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1101 084c 04B04CE2 		sub	fp, ip, #4
 1102 0850 04D04DE2 		sub	sp, sp, #4
 1103 0854 10000BE5 		str	r0, [fp, #-16]
 331:uart.c        ****   if (ch == '\n')
 1105              	.LM102:
 1106 0858 10301BE5 		ldr	r3, [fp, #-16]
 1107 085c 0A0053E3 		cmp	r3, #10
 1108 0860 0100001A 		bne	.L59
 332:uart.c        ****     UARTWriteChar('\r');
 1110              	.LM103:
 1111 0864 0D00A0E3 		mov	r0, #13
 1112 0868 FEFFFFEB 		bl	UARTWriteChar
 1113              	.L59:
 333:uart.c        ****   UARTWriteChar(ch);
 1115              	.LM104:
 1116 086c 10301BE5 		ldr	r3, [fp, #-16]
 1117 0870 FF3003E2 		and	r3, r3, #255
 1118 0874 0300A0E1 		mov	r0, r3
 1119 0878 FEFFFFEB 		bl	UARTWriteChar
 334:uart.c        **** }
 1121              	.LM105:
 1122 087c 0CD04BE2 		sub	sp, fp, #12
 1123 0880 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1124 0884 1EFF2FE1 		bx	lr
 1126              	.Lscope8:
 1127              		.align	2
 1131              		.global	UART_send
 1133              	UART_send:
 335:uart.c        **** 
 336:uart.c        **** void UART_send(char *buffer, unsigned char length)
 337:uart.c        **** {
 1135              	.LM106:
 1136              		@ Function supports interworking.
 1137              		@ args = 0, pretend = 0, frame = 12
 1138              		@ frame_needed = 1, uses_anonymous_args = 0
 1139 0888 0DC0A0E1 		mov	ip, sp
 1140 088c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1141 0890 04B04CE2 		sub	fp, ip, #4
 1142 0894 0CD04DE2 		sub	sp, sp, #12
 1143 0898 14000BE5 		str	r0, [fp, #-20]
 1144 089c 0130A0E1 		mov	r3, r1
 1145 08a0 18304BE5 		strb	r3, [fp, #-24]
 338:uart.c        ****   unsigned char cnt=0;
 1147              	.LM107:
 1148 08a4 0030A0E3 		mov	r3, #0
 1149 08a8 0D304BE5 		strb	r3, [fp, #-13]
 1150              	.L63:
 339:uart.c        ****   while (!(U0LSR & 0x20)); //wait until U0THR and U0TSR are both empty
 1152              	.LM108:
 1153 08ac 0E32A0E3 		mov	r3, #-536870912
 1154 08b0 033983E2 		add	r3, r3, #49152
 1155 08b4 143083E2 		add	r3, r3, #20
 1156 08b8 003093E5 		ldr	r3, [r3, #0]
 1157 08bc 203003E2 		and	r3, r3, #32
 1158 08c0 000053E3 		cmp	r3, #0
 1159 08c4 F8FFFF0A 		beq	.L63
 340:uart.c        ****   while(length--)
 1161              	.LM109:
 1162 08c8 140000EA 		b	.L70
 1163              	.L66:
 341:uart.c        ****   {
 342:uart.c        ****     U0THR = buffer[cnt++];
 1165              	.LM110:
 1166 08cc 0E22A0E3 		mov	r2, #-536870912
 1167 08d0 032982E2 		add	r2, r2, #49152
 1168 08d4 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1169 08d8 0310A0E1 		mov	r1, r3
 1170 08dc 14301BE5 		ldr	r3, [fp, #-20]
 1171 08e0 033081E0 		add	r3, r1, r3
 1172 08e4 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1173 08e8 003082E5 		str	r3, [r2, #0]
 1174 08ec 0D305BE5 		ldrb	r3, [fp, #-13]
 1175 08f0 013083E2 		add	r3, r3, #1
 1176 08f4 0D304BE5 		strb	r3, [fp, #-13]
 343:uart.c        ****     if(cnt>15)
 1178              	.LM111:
 1179 08f8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1180 08fc 0F0053E3 		cmp	r3, #15
 1181 0900 0600009A 		bls	.L65
 1182              	.L67:
 344:uart.c        ****     {
 345:uart.c        ****       while (!(U0LSR & 0x20)); //wait until U0THR is empty
 1184              	.LM112:
 1185 0904 0E32A0E3 		mov	r3, #-536870912
 1186 0908 033983E2 		add	r3, r3, #49152
 1187 090c 143083E2 		add	r3, r3, #20
 1188 0910 003093E5 		ldr	r3, [r3, #0]
 1189 0914 203003E2 		and	r3, r3, #32
 1190 0918 000053E3 		cmp	r3, #0
 1191 091c F8FFFF0A 		beq	.L67
 1192              	.L65:
 1193              	.L70:
 340:uart.c        ****   while(length--)
 1195              	.LM113:
 1196 0920 18305BE5 		ldrb	r3, [fp, #-24]
 1197 0924 013043E2 		sub	r3, r3, #1
 1198 0928 18304BE5 		strb	r3, [fp, #-24]
 1199 092c 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1200 0930 FF0053E3 		cmp	r3, #255
 1201 0934 E4FFFF1A 		bne	.L66
 346:uart.c        ****     }
 347:uart.c        ****   }
 348:uart.c        **** }
 1203              	.LM114:
 1204 0938 0CD04BE2 		sub	sp, fp, #12
 1205 093c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1206 0940 1EFF2FE1 		bx	lr
 1211              	.Lscope9:
 1212              		.align	2
 1216              		.global	UART1_send
 1218              	UART1_send:
 349:uart.c        **** 
 350:uart.c        **** void UART1_send(unsigned char *buffer, unsigned char length)
 351:uart.c        **** {
 1220              	.LM115:
 1221              		@ Function supports interworking.
 1222              		@ args = 0, pretend = 0, frame = 12
 1223              		@ frame_needed = 1, uses_anonymous_args = 0
 1224 0944 0DC0A0E1 		mov	ip, sp
 1225 0948 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1226 094c 04B04CE2 		sub	fp, ip, #4
 1227 0950 0CD04DE2 		sub	sp, sp, #12
 1228 0954 14000BE5 		str	r0, [fp, #-20]
 1229 0958 0130A0E1 		mov	r3, r1
 1230 095c 18304BE5 		strb	r3, [fp, #-24]
 352:uart.c        ****   unsigned char cnt=0;
 1232              	.LM116:
 1233 0960 0030A0E3 		mov	r3, #0
 1234 0964 0D304BE5 		strb	r3, [fp, #-13]
 353:uart.c        ****   while(length--)
 1236              	.LM117:
 1237 0968 110000EA 		b	.L72
 1238              	.L73:
 354:uart.c        ****   {
 355:uart.c        ****     while (!(U1LSR & 0x20)); //wait until U1THR is empty
 1240              	.LM118:
 1241 096c 0E32A0E3 		mov	r3, #-536870912
 1242 0970 013883E2 		add	r3, r3, #65536
 1243 0974 143083E2 		add	r3, r3, #20
 1244 0978 003093E5 		ldr	r3, [r3, #0]
 1245 097c 203003E2 		and	r3, r3, #32
 1246 0980 000053E3 		cmp	r3, #0
 1247 0984 F8FFFF0A 		beq	.L73
 356:uart.c        ****     U1THR = buffer[cnt++];
 1249              	.LM119:
 1250 0988 0E22A0E3 		mov	r2, #-536870912
 1251 098c 012882E2 		add	r2, r2, #65536
 1252 0990 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1253 0994 0310A0E1 		mov	r1, r3
 1254 0998 14301BE5 		ldr	r3, [fp, #-20]
 1255 099c 033081E0 		add	r3, r1, r3
 1256 09a0 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1257 09a4 003082E5 		str	r3, [r2, #0]
 1258 09a8 0D305BE5 		ldrb	r3, [fp, #-13]
 1259 09ac 013083E2 		add	r3, r3, #1
 1260 09b0 0D304BE5 		strb	r3, [fp, #-13]
 1261              	.L72:
 353:uart.c        ****   while(length--)
 1263              	.LM120:
 1264 09b4 18305BE5 		ldrb	r3, [fp, #-24]
 1265 09b8 013043E2 		sub	r3, r3, #1
 1266 09bc 18304BE5 		strb	r3, [fp, #-24]
 1267 09c0 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1268 09c4 FF0053E3 		cmp	r3, #255
 1269 09c8 E7FFFF1A 		bne	.L73
 357:uart.c        ****   }
 358:uart.c        **** }
 1271              	.LM121:
 1272 09cc 0CD04BE2 		sub	sp, fp, #12
 1273 09d0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1274 09d4 1EFF2FE1 		bx	lr
 1279              	.Lscope10:
 1280              		.align	2
 1282              		.global	UART_send_ringbuffer
 1284              	UART_send_ringbuffer:
 359:uart.c        **** 
 360:uart.c        **** 
 361:uart.c        **** void UART_send_ringbuffer(void)
 362:uart.c        **** {
 1286              	.LM122:
 1287              		@ Function supports interworking.
 1288              		@ args = 0, pretend = 0, frame = 4
 1289              		@ frame_needed = 1, uses_anonymous_args = 0
 1290 09d8 0DC0A0E1 		mov	ip, sp
 1291 09dc 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1292 09e0 04B04CE2 		sub	fp, ip, #4
 1293 09e4 04D04DE2 		sub	sp, sp, #4
 363:uart.c        ****   unsigned char t;
 364:uart.c        ****   if(!transmission_running)
 1295              	.LM123:
 1296 09e8 4C309FE5 		ldr	r3, .L82
 1297 09ec 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1298 09f0 000053E3 		cmp	r3, #0
 1299 09f4 0D00001A 		bne	.L81
 365:uart.c        ****   {
 366:uart.c        ****     if(ringbuffer(RBREAD, &t, 1))
 1301              	.LM124:
 1302 09f8 0D304BE2 		sub	r3, fp, #13
 1303 09fc 0000A0E3 		mov	r0, #0
 1304 0a00 0310A0E1 		mov	r1, r3
 1305 0a04 0120A0E3 		mov	r2, #1
 1306 0a08 FEFFFFEB 		bl	ringbuffer
 1307 0a0c 0030A0E1 		mov	r3, r0
 1308 0a10 000053E3 		cmp	r3, #0
 1309 0a14 0500000A 		beq	.L81
 367:uart.c        ****     {
 368:uart.c        ****       transmission_running=1;
 1311              	.LM125:
 1312 0a18 1C209FE5 		ldr	r2, .L82
 1313 0a1c 0130A0E3 		mov	r3, #1
 1314 0a20 0030C2E5 		strb	r3, [r2, #0]
 369:uart.c        ****       UARTWriteChar(t);
 1316              	.LM126:
 1317 0a24 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1318 0a28 0300A0E1 		mov	r0, r3
 1319 0a2c FEFFFFEB 		bl	UARTWriteChar
 1320              	.L81:
 370:uart.c        ****     }
 371:uart.c        ****   }
 372:uart.c        **** }
 1322              	.LM127:
 1323 0a30 0CD04BE2 		sub	sp, fp, #12
 1324 0a34 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1325 0a38 1EFF2FE1 		bx	lr
 1326              	.L83:
 1327              		.align	2
 1328              	.L82:
 1329 0a3c 00000000 		.word	transmission_running
 1334              	.Lscope11:
 1335              		.align	2
 1337              		.global	UART1_send_ringbuffer
 1339              	UART1_send_ringbuffer:
 373:uart.c        **** 
 374:uart.c        **** void UART1_send_ringbuffer(void)
 375:uart.c        **** {
 1341              	.LM128:
 1342              		@ Function supports interworking.
 1343              		@ args = 0, pretend = 0, frame = 4
 1344              		@ frame_needed = 1, uses_anonymous_args = 0
 1345 0a40 0DC0A0E1 		mov	ip, sp
 1346 0a44 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1347 0a48 04B04CE2 		sub	fp, ip, #4
 1348 0a4c 04D04DE2 		sub	sp, sp, #4
 376:uart.c        ****   unsigned char t;
 377:uart.c        ****   if(!transmission1_running)
 1350              	.LM129:
 1351 0a50 4C309FE5 		ldr	r3, .L89
 1352 0a54 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1353 0a58 000053E3 		cmp	r3, #0
 1354 0a5c 0D00001A 		bne	.L88
 378:uart.c        ****   {
 379:uart.c        ****     if(ringbuffer1(RBREAD, &t, 1))
 1356              	.LM130:
 1357 0a60 0D304BE2 		sub	r3, fp, #13
 1358 0a64 0000A0E3 		mov	r0, #0
 1359 0a68 0310A0E1 		mov	r1, r3
 1360 0a6c 0120A0E3 		mov	r2, #1
 1361 0a70 FEFFFFEB 		bl	ringbuffer1
 1362 0a74 0030A0E1 		mov	r3, r0
 1363 0a78 000053E3 		cmp	r3, #0
 1364 0a7c 0500000A 		beq	.L88
 380:uart.c        ****     {
 381:uart.c        ****       transmission1_running=1;
 1366              	.LM131:
 1367 0a80 1C209FE5 		ldr	r2, .L89
 1368 0a84 0130A0E3 		mov	r3, #1
 1369 0a88 0030C2E5 		strb	r3, [r2, #0]
 382:uart.c        ****       UART1WriteChar(t);
 1371              	.LM132:
 1372 0a8c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1373 0a90 0300A0E1 		mov	r0, r3
 1374 0a94 FEFFFFEB 		bl	UART1WriteChar
 1375              	.L88:
 383:uart.c        ****     }
 384:uart.c        ****   }
 385:uart.c        **** }
 1377              	.LM133:
 1378 0a98 0CD04BE2 		sub	sp, fp, #12
 1379 0a9c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1380 0aa0 1EFF2FE1 		bx	lr
 1381              	.L90:
 1382              		.align	2
 1383              	.L89:
 1384 0aa4 00000000 		.word	transmission1_running
 1389              	.Lscope12:
 1390              		.align	2
 1395              		.global	UART_SendPacket
 1397              	UART_SendPacket:
 386:uart.c        **** 
 387:uart.c        **** void UART_SendPacket(void *data, unsigned short count, unsigned char packetdescriptor) //example to
 388:uart.c        **** {
 1399              	.LM134:
 1400              		@ Function supports interworking.
 1401              		@ args = 0, pretend = 0, frame = 20
 1402              		@ frame_needed = 1, uses_anonymous_args = 0
 1403 0aa8 0DC0A0E1 		mov	ip, sp
 1404 0aac 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1405 0ab0 04B04CE2 		sub	fp, ip, #4
 1406 0ab4 14D04DE2 		sub	sp, sp, #20
 1407 0ab8 18000BE5 		str	r0, [fp, #-24]
 1408 0abc 0130A0E1 		mov	r3, r1
 1409 0ac0 BC314BE1 		strh	r3, [fp, #-28]	@ movhi
 1410 0ac4 0230A0E1 		mov	r3, r2
 1411 0ac8 20304BE5 		strb	r3, [fp, #-32]
 389:uart.c        ****   unsigned short crc;
 390:uart.c        ****   int state;
 391:uart.c        ****       state=ringbuffer(RBWRITE, startstring, 3);
 1413              	.LM135:
 1414 0acc 0100A0E3 		mov	r0, #1
 1415 0ad0 C0109FE5 		ldr	r1, .L93
 1416 0ad4 0320A0E3 		mov	r2, #3
 1417 0ad8 FEFFFFEB 		bl	ringbuffer
 1418 0adc 0030A0E1 		mov	r3, r0
 1419 0ae0 10300BE5 		str	r3, [fp, #-16]
 392:uart.c        ****       state=ringbuffer(RBWRITE, (unsigned char *) &count, 2);
 1421              	.LM136:
 1422 0ae4 1C304BE2 		sub	r3, fp, #28
 1423 0ae8 0100A0E3 		mov	r0, #1
 1424 0aec 0310A0E1 		mov	r1, r3
 1425 0af0 0220A0E3 		mov	r2, #2
 1426 0af4 FEFFFFEB 		bl	ringbuffer
 1427 0af8 0030A0E1 		mov	r3, r0
 1428 0afc 10300BE5 		str	r3, [fp, #-16]
 393:uart.c        ****       state=ringbuffer(RBWRITE, &packetdescriptor, 1);
 1430              	.LM137:
 1431 0b00 20304BE2 		sub	r3, fp, #32
 1432 0b04 0100A0E3 		mov	r0, #1
 1433 0b08 0310A0E1 		mov	r1, r3
 1434 0b0c 0120A0E3 		mov	r2, #1
 1435 0b10 FEFFFFEB 		bl	ringbuffer
 1436 0b14 0030A0E1 		mov	r3, r0
 1437 0b18 10300BE5 		str	r3, [fp, #-16]
 394:uart.c        ****       state=ringbuffer(RBWRITE, data, count);
 1439              	.LM138:
 1440 0b1c 18201BE5 		ldr	r2, [fp, #-24]
 1441 0b20 BC315BE1 		ldrh	r3, [fp, #-28]
 1442 0b24 0100A0E3 		mov	r0, #1
 1443 0b28 0210A0E1 		mov	r1, r2
 1444 0b2c 0320A0E1 		mov	r2, r3
 1445 0b30 FEFFFFEB 		bl	ringbuffer
 1446 0b34 0030A0E1 		mov	r3, r0
 1447 0b38 10300BE5 		str	r3, [fp, #-16]
 395:uart.c        ****                 crc=crc16(data,count);
 1449              	.LM139:
 1450 0b3c BC315BE1 		ldrh	r3, [fp, #-28]
 1451 0b40 18001BE5 		ldr	r0, [fp, #-24]
 1452 0b44 0310A0E1 		mov	r1, r3
 1453 0b48 FEFFFFEB 		bl	crc16
 1454 0b4c 0030A0E1 		mov	r3, r0
 1455 0b50 B2314BE1 		strh	r3, [fp, #-18]	@ movhi
 396:uart.c        ****       state=ringbuffer(RBWRITE, (unsigned char *) &crc, 2);
 1457              	.LM140:
 1458 0b54 12304BE2 		sub	r3, fp, #18
 1459 0b58 0100A0E3 		mov	r0, #1
 1460 0b5c 0310A0E1 		mov	r1, r3
 1461 0b60 0220A0E3 		mov	r2, #2
 1462 0b64 FEFFFFEB 		bl	ringbuffer
 1463 0b68 0030A0E1 		mov	r3, r0
 1464 0b6c 10300BE5 		str	r3, [fp, #-16]
 397:uart.c        ****       state=ringbuffer(RBWRITE, stopstring, 3);
 1466              	.LM141:
 1467 0b70 0100A0E3 		mov	r0, #1
 1468 0b74 20109FE5 		ldr	r1, .L93+4
 1469 0b78 0320A0E3 		mov	r2, #3
 1470 0b7c FEFFFFEB 		bl	ringbuffer
 1471 0b80 0030A0E1 		mov	r3, r0
 1472 0b84 10300BE5 		str	r3, [fp, #-16]
 398:uart.c        ****       UART_send_ringbuffer();
 1474              	.LM142:
 1475 0b88 FEFFFFEB 		bl	UART_send_ringbuffer
 399:uart.c        **** }
 1477              	.LM143:
 1478 0b8c 0CD04BE2 		sub	sp, fp, #12
 1479 0b90 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1480 0b94 1EFF2FE1 		bx	lr
 1481              	.L94:
 1482              		.align	2
 1483              	.L93:
 1484 0b98 00000000 		.word	startstring
 1485 0b9c 00000000 		.word	stopstring
 1491              	.Lscope13:
 1492              		.align	2
 1496              		.global	crc_update
 1498              	crc_update:
 400:uart.c        **** 
 401:uart.c        **** //example CRC16 function
 402:uart.c        **** unsigned short crc_update (unsigned short crc, unsigned char data)
 403:uart.c        ****      {
 1500              	.LM144:
 1501              		@ Function supports interworking.
 1502              		@ args = 0, pretend = 0, frame = 8
 1503              		@ frame_needed = 1, uses_anonymous_args = 0
 1504 0ba0 0DC0A0E1 		mov	ip, sp
 1505 0ba4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1506 0ba8 04B04CE2 		sub	fp, ip, #4
 1507 0bac 08D04DE2 		sub	sp, sp, #8
 1508 0bb0 0030A0E1 		mov	r3, r0
 1509 0bb4 0120A0E1 		mov	r2, r1
 1510 0bb8 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 1511 0bbc 0230A0E1 		mov	r3, r2
 1512 0bc0 14304BE5 		strb	r3, [fp, #-20]
 404:uart.c        ****          data ^= (crc & 0xff);
 1514              	.LM145:
 1515 0bc4 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1516 0bc8 FF3003E2 		and	r3, r3, #255
 1517 0bcc FF3003E2 		and	r3, r3, #255
 1518 0bd0 14205BE5 		ldrb	r2, [fp, #-20]	@ zero_extendqisi2
 1519 0bd4 0310A0E1 		mov	r1, r3
 1520 0bd8 0230A0E1 		mov	r3, r2
 1521 0bdc 033021E0 		eor	r3, r1, r3
 1522 0be0 FF3003E2 		and	r3, r3, #255
 1523 0be4 14304BE5 		strb	r3, [fp, #-20]
 405:uart.c        ****          data ^= data << 4;
 1525              	.LM146:
 1526 0be8 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1527 0bec 0332A0E1 		mov	r3, r3, asl #4
 1528 0bf0 FF3003E2 		and	r3, r3, #255
 1529 0bf4 14205BE5 		ldrb	r2, [fp, #-20]	@ zero_extendqisi2
 1530 0bf8 0310A0E1 		mov	r1, r3
 1531 0bfc 0230A0E1 		mov	r3, r2
 1532 0c00 033021E0 		eor	r3, r1, r3
 1533 0c04 FF3003E2 		and	r3, r3, #255
 1534 0c08 14304BE5 		strb	r3, [fp, #-20]
 406:uart.c        **** 
 407:uart.c        ****          return ((((unsigned short )data << 8) | ((crc>>8)&0xff)) ^ (unsigned char )(data >> 4)
 1536              	.LM147:
 1537 0c0c 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1538 0c10 0334A0E1 		mov	r3, r3, asl #8
 1539 0c14 0338A0E1 		mov	r3, r3, asl #16
 1540 0c18 2328A0E1 		mov	r2, r3, lsr #16
 1541 0c1c B0315BE1 		ldrh	r3, [fp, #-16]
 1542 0c20 2334A0E1 		mov	r3, r3, lsr #8
 1543 0c24 0338A0E1 		mov	r3, r3, asl #16
 1544 0c28 2338A0E1 		mov	r3, r3, lsr #16
 1545 0c2c 0338A0E1 		mov	r3, r3, asl #16
 1546 0c30 2338A0E1 		mov	r3, r3, lsr #16
 1547 0c34 FF3003E2 		and	r3, r3, #255
 1548 0c38 033082E1 		orr	r3, r2, r3
 1549 0c3c 0338A0E1 		mov	r3, r3, asl #16
 1550 0c40 2328A0E1 		mov	r2, r3, lsr #16
 1551 0c44 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1552 0c48 2332A0E1 		mov	r3, r3, lsr #4
 1553 0c4c FF3003E2 		and	r3, r3, #255
 1554 0c50 033022E0 		eor	r3, r2, r3
 1555 0c54 0338A0E1 		mov	r3, r3, asl #16
 1556 0c58 2328A0E1 		mov	r2, r3, lsr #16
 1557 0c5c 14305BE5 		ldrb	r3, [fp, #-20]	@ zero_extendqisi2
 1558 0c60 8331A0E1 		mov	r3, r3, asl #3
 1559 0c64 0338A0E1 		mov	r3, r3, asl #16
 1560 0c68 2338A0E1 		mov	r3, r3, lsr #16
 1561 0c6c 033022E0 		eor	r3, r2, r3
 1562 0c70 0338A0E1 		mov	r3, r3, asl #16
 1563 0c74 2338A0E1 		mov	r3, r3, lsr #16
 1564 0c78 0338A0E1 		mov	r3, r3, asl #16
 1565 0c7c 2338A0E1 		mov	r3, r3, lsr #16
 408:uart.c        ****                  ^ ((unsigned short )data << 3));
 409:uart.c        ****      }
 1567              	.LM148:
 1568 0c80 0300A0E1 		mov	r0, r3
 1569 0c84 0CD04BE2 		sub	sp, fp, #12
 1570 0c88 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1571 0c8c 1EFF2FE1 		bx	lr
 1573              	.Lscope14:
 1574              		.align	2
 1578              		.global	crc16
 1580              	crc16:
 410:uart.c        **** 
 411:uart.c        ****  unsigned short crc16(void* data, unsigned short cnt)
 412:uart.c        ****  {
 1582              	.LM149:
 1583              		@ Function supports interworking.
 1584              		@ args = 0, pretend = 0, frame = 20
 1585              		@ frame_needed = 1, uses_anonymous_args = 0
 1586 0c90 0DC0A0E1 		mov	ip, sp
 1587 0c94 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1588 0c98 04B04CE2 		sub	fp, ip, #4
 1589 0c9c 14D04DE2 		sub	sp, sp, #20
 1590 0ca0 1C000BE5 		str	r0, [fp, #-28]
 1591 0ca4 0130A0E1 		mov	r3, r1
 1592 0ca8 B0324BE1 		strh	r3, [fp, #-32]	@ movhi
 413:uart.c        ****    unsigned short crc=0xff;
 1594              	.LM150:
 1595 0cac FF30A0E3 		mov	r3, #255
 1596 0cb0 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 414:uart.c        ****    unsigned char * ptr=(unsigned char *) data;
 1598              	.LM151:
 1599 0cb4 1C301BE5 		ldr	r3, [fp, #-28]
 1600 0cb8 14300BE5 		str	r3, [fp, #-20]
 415:uart.c        ****    int i;
 416:uart.c        **** 
 417:uart.c        ****    for (i=0;i<cnt;i++)
 1602              	.LM152:
 1603 0cbc 0030A0E3 		mov	r3, #0
 1604 0cc0 10300BE5 		str	r3, [fp, #-16]
 1605 0cc4 0D0000EA 		b	.L98
 1606              	.L99:
 418:uart.c        ****      {
 419:uart.c        ****        crc=crc_update(crc,*ptr);
 1608              	.LM153:
 1609 0cc8 B6215BE1 		ldrh	r2, [fp, #-22]
 1610 0ccc 14301BE5 		ldr	r3, [fp, #-20]
 1611 0cd0 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1612 0cd4 0200A0E1 		mov	r0, r2
 1613 0cd8 0310A0E1 		mov	r1, r3
 1614 0cdc FEFFFFEB 		bl	crc_update
 1615 0ce0 0030A0E1 		mov	r3, r0
 1616 0ce4 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 420:uart.c        ****        ptr++;
 1618              	.LM154:
 1619 0ce8 14301BE5 		ldr	r3, [fp, #-20]
 1620 0cec 013083E2 		add	r3, r3, #1
 1621 0cf0 14300BE5 		str	r3, [fp, #-20]
 417:uart.c        ****    for (i=0;i<cnt;i++)
 1623              	.LM155:
 1624 0cf4 10301BE5 		ldr	r3, [fp, #-16]
 1625 0cf8 013083E2 		add	r3, r3, #1
 1626 0cfc 10300BE5 		str	r3, [fp, #-16]
 1627              	.L98:
 1628 0d00 B0225BE1 		ldrh	r2, [fp, #-32]
 1629 0d04 10301BE5 		ldr	r3, [fp, #-16]
 1630 0d08 030052E1 		cmp	r2, r3
 1631 0d0c EDFFFFCA 		bgt	.L99
 421:uart.c        ****      }
 422:uart.c        ****    return crc;
 1633              	.LM156:
 1634 0d10 B6315BE1 		ldrh	r3, [fp, #-22]
 423:uart.c        ****  }
 1636              	.LM157:
 1637 0d14 0300A0E1 		mov	r0, r3
 1638 0d18 0CD04BE2 		sub	sp, fp, #12
 1639 0d1c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1640 0d20 1EFF2FE1 		bx	lr
 1647              	.Lscope15:
 1648              		.bss
 1649 0012 0000     		.align	2
 1650              	content.2606:
 1651 0014 00000000 		.space	4
 1653              		.align	2
 1654              	write_pointer.2605:
 1655 0018 00000000 		.space	4
 1657              		.align	2
 1658              	read_pointer.2604:
 1659 001c 00000000 		.space	4
 1661              	buffer.2603:
 1662 0020 00000000 		.space	384
 1662      00000000 
 1662      00000000 
 1662      00000000 
 1662      00000000 
 1664              		.text
 1665              		.align	2
 1670              		.global	ringbuffer
 1672              	ringbuffer:
 424:uart.c        **** 
 425:uart.c        **** // no longer a ringbuffer! - now it's a FIFO
 426:uart.c        **** int ringbuffer(unsigned char rw, unsigned char *data, unsigned int count)	//returns 1 when write/re
 427:uart.c        **** {
 1674              	.LM158:
 1675              		@ Function supports interworking.
 1676              		@ args = 0, pretend = 0, frame = 24
 1677              		@ frame_needed = 1, uses_anonymous_args = 0
 1678 0d24 0DC0A0E1 		mov	ip, sp
 1679 0d28 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1680 0d2c 04B04CE2 		sub	fp, ip, #4
 1681 0d30 18D04DE2 		sub	sp, sp, #24
 1682 0d34 0030A0E1 		mov	r3, r0
 1683 0d38 1C100BE5 		str	r1, [fp, #-28]
 1684 0d3c 20200BE5 		str	r2, [fp, #-32]
 1685 0d40 18304BE5 		strb	r3, [fp, #-24]
 428:uart.c        ****     static volatile unsigned char buffer[RINGBUFFERSIZE];
 429:uart.c        **** //	static volatile unsigned int pfirst=0, plast=0;	//Pointers to first and last to read byte
 430:uart.c        **** 	static volatile unsigned int read_pointer, write_pointer;
 431:uart.c        **** 	static volatile unsigned int content=0;
 432:uart.c        **** 	unsigned int p=0;
 1687              	.LM159:
 1688 0d44 0030A0E3 		mov	r3, #0
 1689 0d48 14300BE5 		str	r3, [fp, #-20]
 433:uart.c        ****     unsigned int p2=0;
 1691              	.LM160:
 1692 0d4c 0030A0E3 		mov	r3, #0
 1693 0d50 10300BE5 		str	r3, [fp, #-16]
 434:uart.c        **** 
 435:uart.c        **** 	if(rw==RBWRITE)
 1695              	.LM161:
 1696 0d54 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1697 0d58 010053E3 		cmp	r3, #1
 1698 0d5c 2100001A 		bne	.L103
 436:uart.c        **** 	{
 437:uart.c        **** 		if(count<RINGBUFFERSIZE-content)	//enough space in buffer?
 1700              	.LM162:
 1701 0d60 98319FE5 		ldr	r3, .L125
 1702 0d64 003093E5 		ldr	r3, [r3, #0]
 1703 0d68 062D63E2 		rsb	r2, r3, #384
 1704 0d6c 20301BE5 		ldr	r3, [fp, #-32]
 1705 0d70 030052E1 		cmp	r2, r3
 1706 0d74 5A00009A 		bls	.L111
 438:uart.c        **** 		{
 439:uart.c        **** 			while(p<count)
 1708              	.LM163:
 1709 0d78 0D0000EA 		b	.L107
 1710              	.L108:
 440:uart.c        **** 			{
 441:uart.c        **** 				buffer[write_pointer++]=data[p++];
 1712              	.LM164:
 1713 0d7c 80319FE5 		ldr	r3, .L125+4
 1714 0d80 001093E5 		ldr	r1, [r3, #0]
 1715 0d84 14201BE5 		ldr	r2, [fp, #-20]
 1716 0d88 1C301BE5 		ldr	r3, [fp, #-28]
 1717 0d8c 033082E0 		add	r3, r2, r3
 1718 0d90 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1719 0d94 6C219FE5 		ldr	r2, .L125+8
 1720 0d98 0130C2E7 		strb	r3, [r2, r1]
 1721 0d9c 012081E2 		add	r2, r1, #1
 1722 0da0 5C319FE5 		ldr	r3, .L125+4
 1723 0da4 002083E5 		str	r2, [r3, #0]
 1724 0da8 14301BE5 		ldr	r3, [fp, #-20]
 1725 0dac 013083E2 		add	r3, r3, #1
 1726 0db0 14300BE5 		str	r3, [fp, #-20]
 1727              	.L107:
 439:uart.c        **** 			while(p<count)
 1729              	.LM165:
 1730 0db4 14201BE5 		ldr	r2, [fp, #-20]
 1731 0db8 20301BE5 		ldr	r3, [fp, #-32]
 1732 0dbc 030052E1 		cmp	r2, r3
 1733 0dc0 EDFFFF3A 		bcc	.L108
 442:uart.c        **** 			}
 443:uart.c        ****             content+=count;
 1735              	.LM166:
 1736 0dc4 34319FE5 		ldr	r3, .L125
 1737 0dc8 002093E5 		ldr	r2, [r3, #0]
 1738 0dcc 20301BE5 		ldr	r3, [fp, #-32]
 1739 0dd0 032082E0 		add	r2, r2, r3
 1740 0dd4 24319FE5 		ldr	r3, .L125
 1741 0dd8 002083E5 		str	r2, [r3, #0]
 444:uart.c        ****             return(1);
 1743              	.LM167:
 1744 0ddc 0130A0E3 		mov	r3, #1
 1745 0de0 24300BE5 		str	r3, [fp, #-36]
 1746 0de4 400000EA 		b	.L110
 1747              	.L103:
 445:uart.c        **** 		}
 446:uart.c        **** 	}
 447:uart.c        **** 	else if(rw==RBREAD)
 1749              	.LM168:
 1750 0de8 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1751 0dec 000053E3 		cmp	r3, #0
 1752 0df0 2B00001A 		bne	.L112
 448:uart.c        **** 	{
 449:uart.c        **** 		if(content>=count)
 1754              	.LM169:
 1755 0df4 04319FE5 		ldr	r3, .L125
 1756 0df8 002093E5 		ldr	r2, [r3, #0]
 1757 0dfc 20301BE5 		ldr	r3, [fp, #-32]
 1758 0e00 030052E1 		cmp	r2, r3
 1759 0e04 3600003A 		bcc	.L111
 450:uart.c        **** 		{
 451:uart.c        **** 			while(p2<count)
 1761              	.LM170:
 1762 0e08 0E0000EA 		b	.L116
 1763              	.L117:
 452:uart.c        **** 			{
 453:uart.c        **** 				data[p2++]=buffer[read_pointer++];
 1765              	.LM171:
 1766 0e0c 10201BE5 		ldr	r2, [fp, #-16]
 1767 0e10 1C301BE5 		ldr	r3, [fp, #-28]
 1768 0e14 032082E0 		add	r2, r2, r3
 1769 0e18 EC309FE5 		ldr	r3, .L125+12
 1770 0e1c 001093E5 		ldr	r1, [r3, #0]
 1771 0e20 E0309FE5 		ldr	r3, .L125+8
 1772 0e24 0130D3E7 		ldrb	r3, [r3, r1]
 1773 0e28 FF3003E2 		and	r3, r3, #255
 1774 0e2c 0030C2E5 		strb	r3, [r2, #0]
 1775 0e30 10301BE5 		ldr	r3, [fp, #-16]
 1776 0e34 013083E2 		add	r3, r3, #1
 1777 0e38 10300BE5 		str	r3, [fp, #-16]
 1778 0e3c 012081E2 		add	r2, r1, #1
 1779 0e40 C4309FE5 		ldr	r3, .L125+12
 1780 0e44 002083E5 		str	r2, [r3, #0]
 1781              	.L116:
 451:uart.c        **** 			while(p2<count)
 1783              	.LM172:
 1784 0e48 10201BE5 		ldr	r2, [fp, #-16]
 1785 0e4c 20301BE5 		ldr	r3, [fp, #-32]
 1786 0e50 030052E1 		cmp	r2, r3
 1787 0e54 ECFFFF3A 		bcc	.L117
 454:uart.c        **** 			}
 455:uart.c        ****             content-=count;
 1789              	.LM173:
 1790 0e58 A0309FE5 		ldr	r3, .L125
 1791 0e5c 002093E5 		ldr	r2, [r3, #0]
 1792 0e60 20301BE5 		ldr	r3, [fp, #-32]
 1793 0e64 022063E0 		rsb	r2, r3, r2
 1794 0e68 90309FE5 		ldr	r3, .L125
 1795 0e6c 002083E5 		str	r2, [r3, #0]
 456:uart.c        ****             if(!content) //buffer empty
 1797              	.LM174:
 1798 0e70 88309FE5 		ldr	r3, .L125
 1799 0e74 003093E5 		ldr	r3, [r3, #0]
 1800 0e78 000053E3 		cmp	r3, #0
 1801 0e7c 0500001A 		bne	.L119
 457:uart.c        ****             {
 458:uart.c        ****             	write_pointer=0;
 1803              	.LM175:
 1804 0e80 7C209FE5 		ldr	r2, .L125+4
 1805 0e84 0030A0E3 		mov	r3, #0
 1806 0e88 003082E5 		str	r3, [r2, #0]
 459:uart.c        ****             	read_pointer=0;
 1808              	.LM176:
 1809 0e8c 78209FE5 		ldr	r2, .L125+12
 1810 0e90 0030A0E3 		mov	r3, #0
 1811 0e94 003082E5 		str	r3, [r2, #0]
 1812              	.L119:
 460:uart.c        ****             }
 461:uart.c        **** 			return(1);
 1814              	.LM177:
 1815 0e98 0130A0E3 		mov	r3, #1
 1816 0e9c 24300BE5 		str	r3, [fp, #-36]
 1817 0ea0 110000EA 		b	.L110
 1818              	.L112:
 462:uart.c        **** 		}
 463:uart.c        **** 	}
 464:uart.c        ****         else if(rw==RBFREE)
 1820              	.LM178:
 1821 0ea4 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1822 0ea8 020053E3 		cmp	r3, #2
 1823 0eac 0C00001A 		bne	.L111
 465:uart.c        ****         {
 466:uart.c        ****           if(content) return 0;
 1825              	.LM179:
 1826 0eb0 48309FE5 		ldr	r3, .L125
 1827 0eb4 003093E5 		ldr	r3, [r3, #0]
 1828 0eb8 000053E3 		cmp	r3, #0
 1829 0ebc 0200000A 		beq	.L122
 1830 0ec0 0030A0E3 		mov	r3, #0
 1831 0ec4 24300BE5 		str	r3, [fp, #-36]
 1832 0ec8 070000EA 		b	.L110
 1833              	.L122:
 467:uart.c        ****           else return(RINGBUFFERSIZE-11);
 1835              	.LM180:
 1836 0ecc 5D3FA0E3 		mov	r3, #372
 1837 0ed0 24300BE5 		str	r3, [fp, #-36]
 1838 0ed4 24301BE5 		ldr	r3, [fp, #-36]
 1839 0ed8 013083E2 		add	r3, r3, #1
 1840 0edc 24300BE5 		str	r3, [fp, #-36]
 1841 0ee0 010000EA 		b	.L110
 1842              	.L111:
 468:uart.c        ****         }
 469:uart.c        **** 
 470:uart.c        **** 	return(0);
 1844              	.LM181:
 1845 0ee4 0030A0E3 		mov	r3, #0
 1846 0ee8 24300BE5 		str	r3, [fp, #-36]
 1847              	.L110:
 1848 0eec 24301BE5 		ldr	r3, [fp, #-36]
 471:uart.c        **** }
 1850              	.LM182:
 1851 0ef0 0300A0E1 		mov	r0, r3
 1852 0ef4 0CD04BE2 		sub	sp, fp, #12
 1853 0ef8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1854 0efc 1EFF2FE1 		bx	lr
 1855              	.L126:
 1856              		.align	2
 1857              	.L125:
 1858 0f00 14000000 		.word	content.2606
 1859 0f04 18000000 		.word	write_pointer.2605
 1860 0f08 20000000 		.word	buffer.2603
 1861 0f0c 1C000000 		.word	read_pointer.2604
 1871              	.Lscope16:
 1872              		.bss
 1873              		.align	2
 1874              	content.2660:
 1875 01a0 00000000 		.space	4
 1877              		.align	2
 1878              	write_pointer.2659:
 1879 01a4 00000000 		.space	4
 1881              		.align	2
 1882              	read_pointer.2658:
 1883 01a8 00000000 		.space	4
 1885              	buffer.2657:
 1886 01ac 00000000 		.space	384
 1886      00000000 
 1886      00000000 
 1886      00000000 
 1886      00000000 
 1888              		.text
 1889              		.align	2
 1894              		.global	ringbuffer1
 1896              	ringbuffer1:
 472:uart.c        **** 
 473:uart.c        **** int ringbuffer1(unsigned char rw, unsigned char *data, unsigned int count)	//returns 1 when write/r
 474:uart.c        **** {
 1898              	.LM183:
 1899              		@ Function supports interworking.
 1900              		@ args = 0, pretend = 0, frame = 24
 1901              		@ frame_needed = 1, uses_anonymous_args = 0
 1902 0f10 0DC0A0E1 		mov	ip, sp
 1903 0f14 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1904 0f18 04B04CE2 		sub	fp, ip, #4
 1905 0f1c 18D04DE2 		sub	sp, sp, #24
 1906 0f20 0030A0E1 		mov	r3, r0
 1907 0f24 1C100BE5 		str	r1, [fp, #-28]
 1908 0f28 20200BE5 		str	r2, [fp, #-32]
 1909 0f2c 18304BE5 		strb	r3, [fp, #-24]
 475:uart.c        ****     static volatile unsigned char buffer[RINGBUFFERSIZE];
 476:uart.c        **** //	static volatile unsigned int pfirst=0, plast=0;	//Pointers to first and last to read byte
 477:uart.c        **** 	static volatile unsigned int read_pointer, write_pointer;
 478:uart.c        **** 	static volatile unsigned int content=0;
 479:uart.c        **** 	unsigned int p=0;
 1911              	.LM184:
 1912 0f30 0030A0E3 		mov	r3, #0
 1913 0f34 14300BE5 		str	r3, [fp, #-20]
 480:uart.c        ****     unsigned int p2=0;
 1915              	.LM185:
 1916 0f38 0030A0E3 		mov	r3, #0
 1917 0f3c 10300BE5 		str	r3, [fp, #-16]
 481:uart.c        **** 
 482:uart.c        **** 	if(rw==RBWRITE)
 1919              	.LM186:
 1920 0f40 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1921 0f44 010053E3 		cmp	r3, #1
 1922 0f48 2100001A 		bne	.L128
 483:uart.c        **** 	{
 484:uart.c        **** 		if(count<RINGBUFFERSIZE-content)	//enough space in buffer?
 1924              	.LM187:
 1925 0f4c 98319FE5 		ldr	r3, .L150
 1926 0f50 003093E5 		ldr	r3, [r3, #0]
 1927 0f54 062D63E2 		rsb	r2, r3, #384
 1928 0f58 20301BE5 		ldr	r3, [fp, #-32]
 1929 0f5c 030052E1 		cmp	r2, r3
 1930 0f60 5A00009A 		bls	.L136
 485:uart.c        **** 		{
 486:uart.c        **** 			while(p<count)
 1932              	.LM188:
 1933 0f64 0D0000EA 		b	.L132
 1934              	.L133:
 487:uart.c        **** 			{
 488:uart.c        **** 				buffer[write_pointer++]=data[p++];
 1936              	.LM189:
 1937 0f68 80319FE5 		ldr	r3, .L150+4
 1938 0f6c 001093E5 		ldr	r1, [r3, #0]
 1939 0f70 14201BE5 		ldr	r2, [fp, #-20]
 1940 0f74 1C301BE5 		ldr	r3, [fp, #-28]
 1941 0f78 033082E0 		add	r3, r2, r3
 1942 0f7c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1943 0f80 6C219FE5 		ldr	r2, .L150+8
 1944 0f84 0130C2E7 		strb	r3, [r2, r1]
 1945 0f88 012081E2 		add	r2, r1, #1
 1946 0f8c 5C319FE5 		ldr	r3, .L150+4
 1947 0f90 002083E5 		str	r2, [r3, #0]
 1948 0f94 14301BE5 		ldr	r3, [fp, #-20]
 1949 0f98 013083E2 		add	r3, r3, #1
 1950 0f9c 14300BE5 		str	r3, [fp, #-20]
 1951              	.L132:
 486:uart.c        **** 			while(p<count)
 1953              	.LM190:
 1954 0fa0 14201BE5 		ldr	r2, [fp, #-20]
 1955 0fa4 20301BE5 		ldr	r3, [fp, #-32]
 1956 0fa8 030052E1 		cmp	r2, r3
 1957 0fac EDFFFF3A 		bcc	.L133
 489:uart.c        **** 			}
 490:uart.c        ****             content+=count;
 1959              	.LM191:
 1960 0fb0 34319FE5 		ldr	r3, .L150
 1961 0fb4 002093E5 		ldr	r2, [r3, #0]
 1962 0fb8 20301BE5 		ldr	r3, [fp, #-32]
 1963 0fbc 032082E0 		add	r2, r2, r3
 1964 0fc0 24319FE5 		ldr	r3, .L150
 1965 0fc4 002083E5 		str	r2, [r3, #0]
 491:uart.c        ****             return(1);
 1967              	.LM192:
 1968 0fc8 0130A0E3 		mov	r3, #1
 1969 0fcc 24300BE5 		str	r3, [fp, #-36]
 1970 0fd0 400000EA 		b	.L135
 1971              	.L128:
 492:uart.c        **** 		}
 493:uart.c        **** 	}
 494:uart.c        **** 	else if(rw==RBREAD)
 1973              	.LM193:
 1974 0fd4 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 1975 0fd8 000053E3 		cmp	r3, #0
 1976 0fdc 2B00001A 		bne	.L137
 495:uart.c        **** 	{
 496:uart.c        **** 		if(content>=count)
 1978              	.LM194:
 1979 0fe0 04319FE5 		ldr	r3, .L150
 1980 0fe4 002093E5 		ldr	r2, [r3, #0]
 1981 0fe8 20301BE5 		ldr	r3, [fp, #-32]
 1982 0fec 030052E1 		cmp	r2, r3
 1983 0ff0 3600003A 		bcc	.L136
 497:uart.c        **** 		{
 498:uart.c        **** 			while(p2<count)
 1985              	.LM195:
 1986 0ff4 0E0000EA 		b	.L141
 1987              	.L142:
 499:uart.c        **** 			{
 500:uart.c        **** 				data[p2++]=buffer[read_pointer++];
 1989              	.LM196:
 1990 0ff8 10201BE5 		ldr	r2, [fp, #-16]
 1991 0ffc 1C301BE5 		ldr	r3, [fp, #-28]
 1992 1000 032082E0 		add	r2, r2, r3
 1993 1004 EC309FE5 		ldr	r3, .L150+12
 1994 1008 001093E5 		ldr	r1, [r3, #0]
 1995 100c E0309FE5 		ldr	r3, .L150+8
 1996 1010 0130D3E7 		ldrb	r3, [r3, r1]
 1997 1014 FF3003E2 		and	r3, r3, #255
 1998 1018 0030C2E5 		strb	r3, [r2, #0]
 1999 101c 10301BE5 		ldr	r3, [fp, #-16]
 2000 1020 013083E2 		add	r3, r3, #1
 2001 1024 10300BE5 		str	r3, [fp, #-16]
 2002 1028 012081E2 		add	r2, r1, #1
 2003 102c C4309FE5 		ldr	r3, .L150+12
 2004 1030 002083E5 		str	r2, [r3, #0]
 2005              	.L141:
 498:uart.c        **** 			while(p2<count)
 2007              	.LM197:
 2008 1034 10201BE5 		ldr	r2, [fp, #-16]
 2009 1038 20301BE5 		ldr	r3, [fp, #-32]
 2010 103c 030052E1 		cmp	r2, r3
 2011 1040 ECFFFF3A 		bcc	.L142
 501:uart.c        **** 			}
 502:uart.c        ****             content-=count;
 2013              	.LM198:
 2014 1044 A0309FE5 		ldr	r3, .L150
 2015 1048 002093E5 		ldr	r2, [r3, #0]
 2016 104c 20301BE5 		ldr	r3, [fp, #-32]
 2017 1050 022063E0 		rsb	r2, r3, r2
 2018 1054 90309FE5 		ldr	r3, .L150
 2019 1058 002083E5 		str	r2, [r3, #0]
 503:uart.c        ****             if(!content) //buffer empty
 2021              	.LM199:
 2022 105c 88309FE5 		ldr	r3, .L150
 2023 1060 003093E5 		ldr	r3, [r3, #0]
 2024 1064 000053E3 		cmp	r3, #0
 2025 1068 0500001A 		bne	.L144
 504:uart.c        ****             {
 505:uart.c        ****             	write_pointer=0;
 2027              	.LM200:
 2028 106c 7C209FE5 		ldr	r2, .L150+4
 2029 1070 0030A0E3 		mov	r3, #0
 2030 1074 003082E5 		str	r3, [r2, #0]
 506:uart.c        ****             	read_pointer=0;
 2032              	.LM201:
 2033 1078 78209FE5 		ldr	r2, .L150+12
 2034 107c 0030A0E3 		mov	r3, #0
 2035 1080 003082E5 		str	r3, [r2, #0]
 2036              	.L144:
 507:uart.c        ****             }
 508:uart.c        **** 			return(1);
 2038              	.LM202:
 2039 1084 0130A0E3 		mov	r3, #1
 2040 1088 24300BE5 		str	r3, [fp, #-36]
 2041 108c 110000EA 		b	.L135
 2042              	.L137:
 509:uart.c        **** 		}
 510:uart.c        **** 	}
 511:uart.c        ****         else if(rw==RBFREE)
 2044              	.LM203:
 2045 1090 18305BE5 		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 2046 1094 020053E3 		cmp	r3, #2
 2047 1098 0C00001A 		bne	.L136
 512:uart.c        ****         {
 513:uart.c        ****           if(content) return 0;
 2049              	.LM204:
 2050 109c 48309FE5 		ldr	r3, .L150
 2051 10a0 003093E5 		ldr	r3, [r3, #0]
 2052 10a4 000053E3 		cmp	r3, #0
 2053 10a8 0200000A 		beq	.L147
 2054 10ac 0030A0E3 		mov	r3, #0
 2055 10b0 24300BE5 		str	r3, [fp, #-36]
 2056 10b4 070000EA 		b	.L135
 2057              	.L147:
 514:uart.c        ****           else return(RINGBUFFERSIZE-11);
 2059              	.LM205:
 2060 10b8 5D3FA0E3 		mov	r3, #372
 2061 10bc 24300BE5 		str	r3, [fp, #-36]
 2062 10c0 24301BE5 		ldr	r3, [fp, #-36]
 2063 10c4 013083E2 		add	r3, r3, #1
 2064 10c8 24300BE5 		str	r3, [fp, #-36]
 2065 10cc 010000EA 		b	.L135
 2066              	.L136:
 515:uart.c        ****         }
 516:uart.c        **** 
 517:uart.c        **** 	return(0);
 2068              	.LM206:
 2069 10d0 0030A0E3 		mov	r3, #0
 2070 10d4 24300BE5 		str	r3, [fp, #-36]
 2071              	.L135:
 2072 10d8 24301BE5 		ldr	r3, [fp, #-36]
 518:uart.c        **** }
 2074              	.LM207:
 2075 10dc 0300A0E1 		mov	r0, r3
 2076 10e0 0CD04BE2 		sub	sp, fp, #12
 2077 10e4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2078 10e8 1EFF2FE1 		bx	lr
 2079              	.L151:
 2080              		.align	2
 2081              	.L150:
 2082 10ec A0010000 		.word	content.2660
 2083 10f0 A4010000 		.word	write_pointer.2659
 2084 10f4 AC010000 		.word	buffer.2657
 2085 10f8 A8010000 		.word	read_pointer.2658
 2095              	.Lscope17:
 2096              		.comm	GPS_timeout,4,4
 2097              		.comm	SYSTEM_initialized,1,1
 2098              		.comm	send_buffer,16,1
 2099              		.comm	SSP_trans_cnt,4,4
 2100              		.comm	packets,1,1
 2101              		.comm	DataOutputsPerSecond,1,1
 2102              		.comm	uart_cnt,4,4
 2103              		.comm	current_chksum,2,2
 2104              		.comm	tx_buff,4,4
 2105              		.comm	UART_rxptr,4,4
 2106              		.comm	UART1_rxptr,4,4
 2107              		.comm	my_buffer,256,1
 2136              	.Letext0:
 2137              		.ident	"GCC: (GNU) 4.1.1"
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
     /tmp/ccwxEHQ8.s:147    .bss:00000000 data_requested
     /tmp/ccwxEHQ8.s:148    .bss:00000000 $d
     /tmp/ccwxEHQ8.s:152    .bss:00000001 chksum_to_check
     /tmp/ccwxEHQ8.s:158    .data:00000000 chksum_trigger
     /tmp/ccwxEHQ8.s:164    .bss:00000002 transmission_running
     /tmp/ccwxEHQ8.s:169    .bss:00000003 transmission1_running
     /tmp/ccwxEHQ8.s:174    .bss:00000004 trigger_transmission
     /tmp/ccwxEHQ8.s:179    .bss:00000005 baudrate1_change
     /tmp/ccwxEHQ8.s:184    .bss:00000006 UART_syncstate
     /tmp/ccwxEHQ8.s:189    .bss:00000007 UART1_syncstate
     /tmp/ccwxEHQ8.s:195    .bss:00000008 UART_rxcount
     /tmp/ccwxEHQ8.s:201    .bss:0000000c UART1_rxcount
     /tmp/ccwxEHQ8.s:206    .bss:00000010 UART_CalibDoneFlag
     /tmp/ccwxEHQ8.s:208    .bss:00000011 rb_busy
     /tmp/ccwxEHQ8.s:214    .data:00000001 startstring
     /tmp/ccwxEHQ8.s:221    .data:00000004 stopstring
     /tmp/ccwxEHQ8.s:226    .text:00000000 $a
     /tmp/ccwxEHQ8.s:230    .text:00000000 uart1ISR
     /tmp/ccwxEHQ8.s:1896   .text:00000f10 ringbuffer1
     /tmp/ccwxEHQ8.s:979    .text:00000764 UART1WriteChar
     /tmp/ccwxEHQ8.s:314    .text:000000cc $d
     /tmp/ccwxEHQ8.s:322    .text:000000d0 $a
     /tmp/ccwxEHQ8.s:326    .text:000000d0 uart0ISR
     /tmp/ccwxEHQ8.s:1672   .text:00000d24 ringbuffer
     /tmp/ccwxEHQ8.s:939    .text:00000714 UARTWriteChar
     /tmp/ccwxEHQ8.s:440    .text:000001f8 $d
     /tmp/ccwxEHQ8.s:452    .text:0000021c $a
     /tmp/ccwxEHQ8.s:761    .text:00000574 $d
                            *COM*:00000100 my_buffer
     /tmp/ccwxEHQ8.s:788    .text:000005bc $a
     /tmp/ccwxEHQ8.s:793    .text:000005bc UARTInitialize
     /tmp/ccwxEHQ8.s:866    .text:00000668 UART1Initialize
     /tmp/ccwxEHQ8.s:1018   .text:000007b4 UARTReadChar
     /tmp/ccwxEHQ8.s:1055   .text:000007fc UART1ReadChar
     /tmp/ccwxEHQ8.s:1093   .text:00000844 __putchar
     /tmp/ccwxEHQ8.s:1133   .text:00000888 UART_send
     /tmp/ccwxEHQ8.s:1218   .text:00000944 UART1_send
     /tmp/ccwxEHQ8.s:1284   .text:000009d8 UART_send_ringbuffer
     /tmp/ccwxEHQ8.s:1329   .text:00000a3c $d
     /tmp/ccwxEHQ8.s:1335   .text:00000a40 $a
     /tmp/ccwxEHQ8.s:1339   .text:00000a40 UART1_send_ringbuffer
     /tmp/ccwxEHQ8.s:1384   .text:00000aa4 $d
     /tmp/ccwxEHQ8.s:1390   .text:00000aa8 $a
     /tmp/ccwxEHQ8.s:1397   .text:00000aa8 UART_SendPacket
     /tmp/ccwxEHQ8.s:1580   .text:00000c90 crc16
     /tmp/ccwxEHQ8.s:1484   .text:00000b98 $d
     /tmp/ccwxEHQ8.s:1492   .text:00000ba0 $a
     /tmp/ccwxEHQ8.s:1498   .text:00000ba0 crc_update
     /tmp/ccwxEHQ8.s:1650   .bss:00000014 content.2606
     /tmp/ccwxEHQ8.s:1654   .bss:00000018 write_pointer.2605
     /tmp/ccwxEHQ8.s:1658   .bss:0000001c read_pointer.2604
     /tmp/ccwxEHQ8.s:1661   .bss:00000020 buffer.2603
     /tmp/ccwxEHQ8.s:1858   .text:00000f00 $d
     /tmp/ccwxEHQ8.s:1874   .bss:000001a0 content.2660
     /tmp/ccwxEHQ8.s:1878   .bss:000001a4 write_pointer.2659
     /tmp/ccwxEHQ8.s:1882   .bss:000001a8 read_pointer.2658
     /tmp/ccwxEHQ8.s:1885   .bss:000001ac buffer.2657
     /tmp/ccwxEHQ8.s:1889   .text:00000f10 $a
     /tmp/ccwxEHQ8.s:2082   .text:000010ec $d
                            *COM*:00000004 GPS_timeout
                            *COM*:00000001 SYSTEM_initialized
                            *COM*:00000010 send_buffer
                            *COM*:00000004 SSP_trans_cnt
                            *COM*:00000001 packets
                            *COM*:00000001 DataOutputsPerSecond
                            *COM*:00000004 uart_cnt
                            *COM*:00000002 current_chksum
                            *COM*:00000004 tx_buff
                            *COM*:00000004 UART_rxptr
                            *COM*:00000004 UART1_rxptr

UNDEFINED SYMBOLS
uBloxReceiveHandler
__nesf2
my_receive
getPackageLength
memcpy
allDataBuffer
pack_id
receivedViconData
my_state
vicon_count
receiveDebugData
vicon_tp
receiveParamDebug
receive_valid_data_flag
my_this
my_setpoint
receiveCmdData
receivePositionWayPointData
receiveLandSignal
__udivsi3
peripheralClockFrequency
